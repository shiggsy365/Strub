Index: app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.stremiompvplayer.network\n\nimport com.squareup.moshi.Moshi\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\nimport retrofit2.Retrofit\nimport retrofit2.converter.moshi.MoshiConverterFactory\nimport retrofit2.http.*\n\nobject TraktClient {\n    private const val BASE_URL = \"https://api.trakt.tv/\"\n\n    private val moshi = Moshi.Builder()\n        .add(KotlinJsonAdapterFactory())\n        .build()\n\n    private val retrofit = Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .addConverterFactory(MoshiConverterFactory.create(moshi))\n        .build()\n\n    val api: TraktApi = retrofit.create(TraktApi::class.java)\n}\n\ninterface TraktApi {\n    // --- AUTH ---\n    @POST(\"oauth/device/code\")\n    suspend fun getDeviceCode(@Body body: Map<String, String>): TraktDeviceCodeResponse\n\n    @POST(\"oauth/device/token\")\n    suspend fun getDeviceToken(@Body body: Map<String, String>): TraktTokenResponse\n\n    // --- SYNC & HISTORY ---\n    @GET(\"sync/watched/movies\")\n    suspend fun getWatchedMovies(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String\n    ): List<TraktWatchedItem>\n\n    @GET(\"sync/watched/shows\")\n    suspend fun getWatchedShows(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String\n    ): List<TraktWatchedItem>\n\n    // --- PLAYBACK (CONTINUE WATCHING) ---\n    @GET(\"sync/playback/movies\")\n    suspend fun getPausedMovies(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Query(\"limit\") limit: Int = 20\n    ): List<TraktPlaybackItem>\n\n    @GET(\"sync/playback/episodes\")\n    suspend fun getPausedEpisodes(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Query(\"limit\") limit: Int = 20\n    ): List<TraktPlaybackItem>\n\n    // --- COLLECTIONS & LISTS ---\n    @GET(\"sync/collection/movies\")\n    suspend fun getMovieCollection(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String\n    ): List<TraktCollectionItem>\n\n    @GET(\"sync/collection/shows\")\n    suspend fun getShowCollection(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String\n    ): List<TraktCollectionItem>\n\n    @GET(\"sync/watchlist\")\n    suspend fun getWatchlist(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Query(\"type\") type: String? = null\n    ): List<TraktListItem>\n\n    // --- ACTIONS ---\n    @POST(\"sync/history\")\n    suspend fun addToHistory(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Body body: TraktHistoryBody\n    ): TraktSyncResponse\n\n    @POST(\"sync/history/remove\")\n    suspend fun removeFromHistory(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Body body: TraktHistoryBody\n    ): TraktSyncResponse\n\n    // --- DISCOVER ---\n    @GET(\"movies/popular\")\n    suspend fun getPopularMovies(@Header(\"trakt-api-key\") clientId: String): List<TraktMovie>\n    @GET(\"shows/popular\")\n    suspend fun getPopularShows(@Header(\"trakt-api-key\") clientId: String): List<TraktShow>\n    @GET(\"movies/trending\")\n    suspend fun getTrendingMovies(@Header(\"trakt-api-key\") clientId: String): List<TraktTrendingItem>\n    @GET(\"shows/trending\")\n    suspend fun getTrendingShows(@Header(\"trakt-api-key\") clientId: String): List<TraktTrendingItem>\n\n    // --- SCROBBLE ---\n    @POST(\"scrobble/start\")\n    suspend fun startScrobble(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Body body: TraktScrobbleBody\n    ): TraktScrobbleResponse\n\n    @POST(\"scrobble/pause\")\n    suspend fun pauseScrobble(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Body body: TraktScrobbleBody\n    ): TraktScrobbleResponse\n\n    @POST(\"scrobble/stop\")\n    suspend fun stopScrobble(\n        @Header(\"Authorization\") token: String,\n        @Header(\"trakt-api-key\") clientId: String,\n        @Body body: TraktScrobbleBody\n    ): TraktScrobbleResponse\n}\n\n// --- Data Models ---\ndata class TraktDeviceCodeResponse(val device_code: String, val user_code: String, val verification_url: String, val expires_in: Int, val interval: Int)\ndata class TraktTokenResponse(val access_token: String, val refresh_token: String)\ndata class TraktWatchedItem(val last_watched_at: String?, val plays: Int, val movie: TraktMovie?, val show: TraktShow?, val seasons: List<TraktSeason>?)\ndata class TraktCollectionItem(val last_collected_at: String?, val movie: TraktMovie?, val show: TraktShow?)\ndata class TraktListItem(val type: String, val movie: TraktMovie?, val show: TraktShow?)\ndata class TraktTrendingItem(val watchers: Int, val movie: TraktMovie?, val show: TraktShow?)\n\n// NEW: Playback (Paused) Item\ndata class TraktPlaybackItem(\n    val progress: Float?,\n    val paused_at: String?,\n    val id: Long?,\n    val type: String?,\n    val movie: TraktMovie?,\n    val show: TraktShow?,\n    val episode: TraktEpisode?\n)\n\ndata class TraktMovie(val title: String, val year: Int?, val ids: TraktIds)\ndata class TraktShow(val title: String, val year: Int?, val ids: TraktIds)\ndata class TraktSeason(val number: Int, val episodes: List<TraktEpisode>)\ndata class TraktEpisode(val number: Int, val plays: Int = 0, val last_watched_at: String? = null, val ids: TraktIds? = null)\ndata class TraktIds(val trakt: Int, val tmdb: Int?, val imdb: String?, val slug: String?)\n\ndata class TraktHistoryBody(val movies: List<TraktMovie>? = null, val shows: List<TraktShow>? = null, val episodes: List<TraktEpisode>? = null)\ndata class TraktSyncResponse(val added: TraktSyncStats?, val deleted: TraktSyncStats?, val not_found: TraktSyncNotFound?)\ndata class TraktSyncStats(val movies: Int, val episodes: Int)\ndata class TraktSyncNotFound(val movies: List<TraktIds>?, val shows: List<TraktIds>?, val episodes: List<TraktIds>?)\n\ndata class TraktScrobbleBody(val progress: Float, val movie: TraktMovie? = null, val show: TraktShow? = null, val episode: TraktEpisode? = null)\ndata class TraktScrobbleResponse(val action: String?, val progress: Float?)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt b/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt
--- a/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ b/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt	(date 1763932923592)
@@ -4,7 +4,11 @@
 import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
 import retrofit2.Retrofit
 import retrofit2.converter.moshi.MoshiConverterFactory
-import retrofit2.http.*
+import retrofit2.http.Body
+import retrofit2.http.GET
+import retrofit2.http.Header
+import retrofit2.http.POST
+import retrofit2.http.Query
 
 object TraktClient {
     private const val BASE_URL = "https://api.trakt.tv/"
Index: app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.stremiompvplayer.models\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport java.io.Serializable\n\n\n@Dao\ninterface UserCatalogDao {\n\n    // Get all catalogs for a specific user and page type, ordered by display order\n    @Query(\"SELECT * FROM user_catalogs WHERE userId = :userId AND pageType = :pageType ORDER BY displayOrder ASC\")\n    fun getCatalogsForPage(userId: String, pageType: String): LiveData<List<UserCatalog>>\n\n    @Query(\"SELECT * FROM user_catalogs WHERE userId = :userId AND pageType = :pageType ORDER BY displayOrder ASC\")\n    suspend fun getCatalogsForPageSync(userId: String, pageType: String): List<UserCatalog>\n\n    // Get all catalogs (for settings)\n    @Query(\"SELECT * FROM user_catalogs ORDER BY pageType, displayOrder ASC\")\n    fun getAllCatalogs(): LiveData<List<UserCatalog>>\n\n    // Get count for initialization check\n    @Query(\"SELECT COUNT(*) FROM user_catalogs\")\n    suspend fun getCount(): Int\n\n    // Get all catalogs from a specific manifest (for cleanup when manifest changes)\n    @Query(\"SELECT * FROM user_catalogs WHERE userId = :userId AND manifestId = :manifestId\")\n    suspend fun getCatalogsByManifest(userId: String, manifestId: String): List<UserCatalog>\n\n    // Check if a catalog is already added\n    @Query(\"SELECT COUNT(*) FROM user_catalogs WHERE userId = :userId AND catalogId = :catalogId AND catalogType = :catalogType AND pageType = :pageType\")\n    suspend fun isCatalogAdded(userId: String, catalogId: String, catalogType: String, pageType: String): Int\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(catalog: UserCatalog): Long\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(catalogs: List<UserCatalog>)\n\n    @Update\n    suspend fun update(catalog: UserCatalog)\n\n    @Delete\n    suspend fun delete(catalog: UserCatalog)\n\n    // NEW: Delete all catalogs for a user\n    @Query(\"DELETE FROM user_catalogs WHERE userId = :userId\")\n    suspend fun deleteByUser(userId: String)\n\n    // Update display order for a catalog\n    @Query(\"UPDATE user_catalogs SET displayOrder = :newOrder WHERE id = :catalogId\")\n    suspend fun updateDisplayOrder(catalogId: Long, newOrder: Int)\n\n    // Update custom name\n    @Query(\"UPDATE user_catalogs SET customName = :newName WHERE id = :catalogId\")\n    suspend fun updateCustomName(catalogId: Long, newName: String)\n\n    // Get the maximum display order for a page (to add new catalogs at the end)\n    @Query(\"SELECT MAX(displayOrder) FROM user_catalogs WHERE userId = :userId AND pageType = :pageType\")\n    suspend fun getMaxDisplayOrder(userId: String, pageType: String): Int?\n\n    // Delete catalogs from a specific manifest (cleanup when manifest is removed)\n    @Query(\"DELETE FROM user_catalogs WHERE userId = :userId AND manifestId = :manifestId\")\n    suspend fun deleteCatalogsByManifest(userId: String, manifestId: String)\n\n    // Swap sort orders between two catalogs\n    @Transaction\n    suspend fun swapSortOrder(id1: Long, order1: Int, id2: Long, order2: Int) {\n        updateDisplayOrder(id1, order2)\n        updateDisplayOrder(id2, order1)\n    }\n\n    // Get enabled catalogs for user\n    @Query(\"SELECT * FROM user_catalogs WHERE userId = :userId AND pageType = :pageType ORDER BY displayOrder ASC\")\n    suspend fun getEnabledUserCatalogs(pageType: String, userId: String = \"default\"): List<UserCatalog>\n}\n\n@Dao\ninterface CollectedItemDao {\n\n    // Get all collected items for a user, filtered by type\n    @Query(\"SELECT * FROM collected_items WHERE userId = :userId AND itemType = :itemType ORDER BY collectedDate DESC\")\n    fun getCollectedItems(userId: String, itemType: String): LiveData<List<CollectedItem>>\n\n    // Get collected items sorted by name\n    @Query(\"SELECT * FROM collected_items WHERE userId = :userId AND itemType = :itemType ORDER BY name ASC\")\n    fun getCollectedItemsByName(userId: String, itemType: String): LiveData<List<CollectedItem>>\n\n    // Get collected items sorted by date (oldest first)\n    @Query(\"SELECT * FROM collected_items WHERE userId = :userId AND itemType = :itemType ORDER BY collectedDate ASC\")\n    fun getCollectedItemsByDateAsc(userId: String, itemType: String): LiveData<List<CollectedItem>>\n\n    // Check if an item is collected\n    @Query(\"SELECT COUNT(*) FROM collected_items WHERE id = :id\")\n    suspend fun isCollected(id: String): Int\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(item: CollectedItem)\n\n    @Delete\n    suspend fun delete(item: CollectedItem)\n\n    // Delete by composite ID\n    @Query(\"DELETE FROM collected_items WHERE id = :id\")\n    suspend fun deleteById(id: String)\n\n    // NEW: Delete by User ID\n    @Query(\"DELETE FROM collected_items WHERE userId = :userId\")\n    suspend fun deleteByUser(userId: String)\n\n    // Get single item\n    @Query(\"SELECT * FROM collected_items WHERE id = :id\")\n    suspend fun getItemById(id: String): CollectedItem?\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt b/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt
--- a/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ b/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt	(date 1763934117683)
@@ -1,9 +1,15 @@
 package com.example.stremiompvplayer.models
 
 import androidx.lifecycle.LiveData
-import androidx.room.*
+import androidx.room.Dao
+import androidx.room.Delete
 import androidx.room.Entity
+import androidx.room.Insert
+import androidx.room.OnConflictStrategy
 import androidx.room.PrimaryKey
+import androidx.room.Query
+import androidx.room.Transaction
+import androidx.room.Update
 import java.io.Serializable
 
 
Index: app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.stremiompvplayer.network\n\nimport com.example.stremiompvplayer.models.*\nimport retrofit2.http.Body\nimport retrofit2.http.GET\nimport retrofit2.http.Header\nimport retrofit2.http.POST\nimport retrofit2.http.Path\nimport retrofit2.http.Query\nimport com.example.stremiompvplayer.models.TMDBCreditsResponse\nimport com.example.stremiompvplayer.models.TMDBAggregateCreditsResponse\n\ninterface TMDBApiService {\n\n    @GET(\"search/person\")\n    suspend fun searchPeople(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"query\") query: String,\n        @Query(\"page\") page: Int = 1,\n        @Query(\"include_adult\") includeAdult: Boolean = false,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBPersonListResponse\n\n    // CREDITS\n    @GET(\"movie/{id}/credits\")\n    suspend fun getMovieCredits(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBCreditsResponse\n\n    @GET(\"tv/{id}/aggregate_credits\")\n    suspend fun getTVAggregateCredits(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBAggregateCreditsResponse\n\n    // DETAILS\n    @GET(\"tv/{id}\")\n    suspend fun getTVDetails(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBTVDetails\n\n    @GET(\"tv/{id}/season/{season_number}\")\n    suspend fun getTVSeasonDetails(\n        @Path(\"id\") id: Int,\n        @Path(\"season_number\") seasonNumber: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBSeasonDetails\n\n\n    // --- AUTHENTICATION ---\n    @GET(\"authentication/token/new\")\n    suspend fun createRequestToken(\n        @Query(\"api_key\") apiKey: String\n    ): TMDBRequestTokenResponse\n\n    @GET(\"tv/{id}/credits\")\n    suspend fun getTVCredits(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String\n    ): TMDBCreditsResponse\n\n    // [FIX] Added include_image_language to filter for English/Neutral logos\n    @GET(\"movie/{id}/images\")\n    suspend fun getMovieImages(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"include_image_language\") includeImageLanguage: String = \"en,null\"\n    ): TMDBImagesResponse\n\n    // [FIX] Added include_image_language to filter for English/Neutral logos\n    @GET(\"tv/{id}/images\")\n    suspend fun getTVImages(\n        @Path(\"id\") id: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"include_image_language\") includeImageLanguage: String = \"en,null\"\n    ): TMDBImagesResponse\n\n    @POST(\"authentication/session/new\")\n    suspend fun createSession(\n        @Query(\"api_key\") apiKey: String,\n        @Body body: Map<String, String> // {\"request_token\": \"...\"}\n    ): TMDBSessionResponse\n\n    // --- EXISTING LISTS (Updated to use api_key) ---\n    @GET(\"movie/popular\")\n    suspend fun getPopularMovies(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"primary_release_date.lte\") releaseDate: String? = null\n    ): TMDBMovieListResponse\n\n    @GET(\"movie/now_playing\")\n    suspend fun getLatestMovies(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"primary_release_date.lte\") releaseDate: String? = null\n    ): TMDBMovieListResponse\n\n    @GET(\"trending/movie/week\")\n    suspend fun getTrendingMovies(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1\n    ): TMDBMovieListResponse\n\n    // --- TV SHOWS (Updated to use api_key) ---\n    @GET(\"tv/popular\")\n    suspend fun getPopularSeries(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"first_air_date.lte\") airDate: String? = null\n    ): TMDBSeriesListResponse\n\n    @GET(\"tv/on_the_air\")\n    suspend fun getLatestSeries(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"first_air_date.lte\") airDate: String? = null\n    ): TMDBSeriesListResponse\n\n    @GET(\"trending/tv/week\")\n    suspend fun getTrendingSeries(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1\n    ): TMDBSeriesListResponse\n\n    // --- SEARCH (Updated to use api_key) ---\n    @GET(\"search/multi\")\n    suspend fun searchMulti(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"query\") query: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"include_adult\") includeAdult: Boolean = false\n    ): TMDBMultiSearchResponse\n\n    @GET(\"search/movie\")\n    suspend fun searchMovies(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"query\") query: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"include_adult\") includeAdult: Boolean = false\n    ): TMDBMovieListResponse\n\n    @GET(\"search/tv\")\n    suspend fun searchSeries(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"query\") query: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"include_adult\") includeAdult: Boolean = false\n    ): TMDBSeriesListResponse\n\n    // --- DETAILS (Updated to use api_key) ---\n    @GET(\"tv/{series_id}\")\n    suspend fun getSeriesDetail(\n        @Path(\"series_id\") seriesId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"append_to_response\") appendToResponse: String = \"external_ids\"\n    ): TMDBSeriesDetailResponse\n\n    @GET(\"movie/{movie_id}/external_ids\")\n    suspend fun getMovieExternalIds(\n        @Path(\"movie_id\") movieId: Int,\n        @Query(\"api_key\") apiKey: String\n    ): TMDBExternalIdsResponse\n\n    @GET(\"tv/{tv_id}/external_ids\")\n    suspend fun getTVExternalIds(\n        @Path(\"tv_id\") tvId: Int,\n        @Query(\"api_key\") apiKey: String\n    ): TMDBExternalIdsResponse\n\n    // --- CREDITS (Updated to use api_key) ---\n\n    @GET(\"tv/{tv_id}/credits\")\n    suspend fun getTVCredits(\n        @Path(\"tv_id\") tvId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBCreditsResponse\n    @GET(\"account\")\n    suspend fun getAccountDetails(\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"session_id\") sessionId: String\n    ): TMDBAccountDetails\n\n    @GET(\"account/{account_id}/watchlist/movies\")\n    suspend fun getMovieWatchlist(\n        @Path(\"account_id\") accountId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"session_id\") sessionId: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"sort_by\") sortBy: String = \"created_at.desc\"\n    ): TMDBMovieListResponse\n\n    @GET(\"account/{account_id}/watchlist/tv\")\n    suspend fun getTVWatchlist(\n        @Path(\"account_id\") accountId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"session_id\") sessionId: String,\n        @Query(\"language\") language: String = \"en-US\",\n        @Query(\"page\") page: Int = 1,\n        @Query(\"sort_by\") sortBy: String = \"created_at.desc\"\n    ): TMDBSeriesListResponse\n\n    // [ADDED] This was missing and causing the unresolved reference error\n    @GET(\"movie/{movie_id}\")\n    suspend fun getMovieDetails(\n        @Path(\"movie_id\") movieId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBMovie\n\n    @POST(\"account/{account_id}/watchlist\")\n    suspend fun addToWatchlist(\n        @Path(\"account_id\") accountId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"session_id\") sessionId: String,\n        @Body body: TMDBWatchlistBody\n    ): TMDBPostResponse\n\n    // --- PERSON ---\n    @GET(\"person/{person_id}/combined_credits\")\n    suspend fun getPersonCombinedCredits(\n        @Path(\"person_id\") personId: Int,\n        @Query(\"api_key\") apiKey: String,\n        @Query(\"language\") language: String = \"en-US\"\n    ): TMDBPersonCreditsResponse\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt b/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt
--- a/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ b/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt	(date 1763934117679)
@@ -1,6 +1,5 @@
 package com.example.stremiompvplayer.network
-
-import com.example.stremiompvplayer.models.*
+import com.example.stremiompvplayer.models.TMDBAccountDetails
 import retrofit2.http.Body
 import retrofit2.http.GET
 import retrofit2.http.Header
@@ -9,6 +8,21 @@
 import retrofit2.http.Query
 import com.example.stremiompvplayer.models.TMDBCreditsResponse
 import com.example.stremiompvplayer.models.TMDBAggregateCreditsResponse
+import com.example.stremiompvplayer.models.TMDBExternalIdsResponse
+import com.example.stremiompvplayer.models.TMDBImagesResponse
+import com.example.stremiompvplayer.models.TMDBMovie
+import com.example.stremiompvplayer.models.TMDBMovieListResponse
+import com.example.stremiompvplayer.models.TMDBMultiSearchResponse
+import com.example.stremiompvplayer.models.TMDBPersonCreditsResponse
+import com.example.stremiompvplayer.models.TMDBPersonListResponse
+import com.example.stremiompvplayer.models.TMDBPostResponse
+import com.example.stremiompvplayer.models.TMDBRequestTokenResponse
+import com.example.stremiompvplayer.models.TMDBSeasonDetails
+import com.example.stremiompvplayer.models.TMDBSeriesDetailResponse
+import com.example.stremiompvplayer.models.TMDBSeriesListResponse
+import com.example.stremiompvplayer.models.TMDBSessionResponse
+import com.example.stremiompvplayer.models.TMDBTVDetails
+import com.example.stremiompvplayer.models.TMDBWatchlistBody
 
 interface TMDBApiService {
 
Index: app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.stremiompvplayer.viewmodels\n\nimport android.util.Log\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MediatorLiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.map\nimport androidx.lifecycle.viewModelScope\nimport com.example.stremiompvplayer.CatalogRepository\nimport com.example.stremiompvplayer.models.*\nimport com.example.stremiompvplayer.network.*\nimport com.example.stremiompvplayer.utils.Secrets\nimport com.example.stremiompvplayer.utils.SharedPreferencesManager\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.awaitAll\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\n\nclass MainViewModel(\n    private val catalogRepository: CatalogRepository,\n    private val prefsManager: SharedPreferencesManager\n) : ViewModel() {\n\n    // --- Core LiveData ---\n    private val _currentCatalogContent = MutableLiveData<List<MetaItem>>()\n    val currentCatalogContent: LiveData<List<MetaItem>> = _currentCatalogContent\n\n    private val _currentLogo = MutableLiveData<String?>()\n    val currentLogo: LiveData<String?> = _currentLogo\n    private var logoFetchJob: Job? = null\n\n    private val apiKey: String get() = prefsManager.getTMDBApiKey() ?: \"\"\n\n    // Track current catalog to allow refreshing\n    private var lastRequestedCatalog: UserCatalog? = null\n    private var loadedContentCache: MutableList<MetaItem> = mutableListOf()\n\n    // === CATALOG CONFIGURATION ===\n    // Raw source from DB\n    private val _allCatalogsRaw: LiveData<List<UserCatalog>> = catalogRepository.allCatalogs\n\n    // FILTERED Config List: Used by Settings & Discover\n    // Removes \"Next Up\" and \"Continue Watching\" so they only appear on Home\n    val allCatalogConfigs: LiveData<List<UserCatalog>> = _allCatalogsRaw.map { list ->\n        list.filter { cat ->\n            val id = cat.catalogId\n            // Exclude these IDs from the configurable list\n            id != \"next_up\" &&\n                    id != \"continue_movies\" &&\n                    id != \"continue_episodes\" &&\n                    id != \"trakt_next_up\" &&\n                    id != \"trakt_continue_movies\" &&\n                    id != \"trakt_continue_shows\"\n        }\n    }\n\n    val movieCatalogs = allCatalogConfigs.map { it.filter { c -> c.catalogType == \"movie\" && c.showInUser }.sortedBy { c -> c.displayOrder } }\n    val seriesCatalogs = allCatalogConfigs.map { it.filter { c -> c.catalogType == \"series\" && c.showInUser }.sortedBy { c -> c.displayOrder } }\n\n    // === HOME SCREEN LIVE DATA ===\n    private val _homeNextUp = MutableLiveData<List<MetaItem>>()\n    val homeNextUp: LiveData<List<MetaItem>> = _homeNextUp\n\n    private val _homeContinueEpisodes = MutableLiveData<List<MetaItem>>()\n    val homeContinueEpisodes: LiveData<List<MetaItem>> = _homeContinueEpisodes\n\n    private val _homeContinueMovies = MutableLiveData<List<MetaItem>>()\n    val homeContinueMovies: LiveData<List<MetaItem>> = _homeContinueMovies\n\n    // UI State\n    private val _streams = MutableLiveData<List<Stream>>()\n    val streams: LiveData<List<Stream>> = _streams\n    private val _metaDetails = MutableLiveData<Meta?>()\n    val metaDetails: LiveData<Meta?> = _metaDetails\n    private val _seasonEpisodes = MutableLiveData<List<MetaItem>>()\n    val seasonEpisodes: LiveData<List<MetaItem>> = _seasonEpisodes\n    private val _castList = MutableLiveData<List<MetaItem>>()\n    val castList: LiveData<List<MetaItem>> = _castList\n    private val _director = MutableLiveData<MetaItem?>()\n    val director: LiveData<MetaItem?> = _director\n    private val _error = MutableLiveData<String>()\n    val error: LiveData<String> = _error\n    private val _isLoading = MutableLiveData<Boolean>()\n    val isLoading: LiveData<Boolean> = _isLoading\n    private val _actionResult = MutableLiveData<ActionResult>()\n    val actionResult: LiveData<ActionResult> = _actionResult\n\n    // Trakt State\n    private val _traktDeviceCode = MutableLiveData<TraktDeviceCodeResponse?>()\n    val traktDeviceCode: LiveData<TraktDeviceCodeResponse?> = _traktDeviceCode\n    private val _isTraktEnabled = MutableLiveData<Boolean>(prefsManager.isTraktEnabled())\n    val isTraktEnabled: LiveData<Boolean> = _isTraktEnabled\n    private val _traktSyncProgress = MutableLiveData<String>()\n    val traktSyncProgress: LiveData<String> = _traktSyncProgress\n    private val _traktSyncStatus = MutableLiveData<TraktSyncStatus>()\n    val traktSyncStatus: LiveData<TraktSyncStatus> = _traktSyncStatus\n\n    // Library Sources (Local + Trakt)\n    val libraryMovies = MediatorLiveData<List<MetaItem>>()\n    val librarySeries = MediatorLiveData<List<MetaItem>>()\n\n    private val _localMoviesRaw = catalogRepository.getLibraryItems(prefsManager.getCurrentUserId() ?: \"default\", \"movie\").map { items ->\n        items.map { toMetaItem(it) }\n    }\n    private val _localSeriesRaw = catalogRepository.getLibraryItems(prefsManager.getCurrentUserId() ?: \"default\", \"series\").map { items ->\n        items.map { toMetaItem(it) }\n    }\n\n    private val _traktMoviesRaw = MutableLiveData<List<MetaItem>>()\n    private val _traktSeriesRaw = MutableLiveData<List<MetaItem>>()\n\n    // Filtered library for UI\n    private val _filteredLibraryMovies = MutableLiveData<List<MetaItem>>()\n    val filteredLibraryMovies: LiveData<List<MetaItem>> = _filteredLibraryMovies\n\n    private val _filteredLibrarySeries = MutableLiveData<List<MetaItem>>()\n    val filteredLibrarySeries: LiveData<List<MetaItem>> = _filteredLibrarySeries\n\n    // Library Status Checks\n    private val _isItemInWatchlist = MutableLiveData<Boolean>(false)\n    val isItemInWatchlist: LiveData<Boolean> = _isItemInWatchlist\n    private val _isItemInLibrary = MutableLiveData<Boolean>(false)\n    val isItemInLibrary: LiveData<Boolean> = _isItemInLibrary\n    private val _isItemWatched = MutableLiveData<Boolean>(false)\n    val isItemWatched: LiveData<Boolean> = _isItemWatched\n\n    // Search & Auth\n    private val _searchResults = MutableLiveData<List<MetaItem>>()\n    val searchResults: LiveData<List<MetaItem>> = _searchResults\n    private val _isSearching = MutableLiveData<Boolean>()\n    val isSearching: LiveData<Boolean> = _isSearching\n    private val _requestToken = MutableLiveData<String?>()\n    val requestToken: LiveData<String?> = _requestToken\n    private val _sessionId = MutableLiveData<String?>()\n    val sessionId: LiveData<String?> = _sessionId\n\n    init {\n        setupLibrarySources()\n        initDefaultCatalogs()\n        initUserLists()\n        if (prefsManager.isTraktEnabled()) {\n            syncTraktLibrary()\n            startPeriodicTraktSync()\n        }\n    }\n\n    // === HELPER FUNCTIONS ===\n    private fun toMetaItem(item: CollectedItem): MetaItem {\n        return MetaItem(item.itemId, item.itemType, item.name, item.poster, item.background, item.description)\n    }\n\n    // === LIBRARY SOURCE MANAGEMENT ===\n    private fun setupLibrarySources() {\n        libraryMovies.addSource(_isTraktEnabled) { updateMovieSource() }\n        libraryMovies.addSource(_localMoviesRaw) { updateMovieSource() }\n        libraryMovies.addSource(_traktMoviesRaw) { updateMovieSource() }\n\n        librarySeries.addSource(_isTraktEnabled) { updateSeriesSource() }\n        librarySeries.addSource(_localSeriesRaw) { updateSeriesSource() }\n        librarySeries.addSource(_traktSeriesRaw) { updateSeriesSource() }\n    }\n\n    private fun updateMovieSource() {\n        val localItems = _localMoviesRaw.value ?: emptyList()\n        val traktItems = if (_isTraktEnabled.value == true) _traktMoviesRaw.value ?: emptyList() else emptyList()\n        val combined = (localItems + traktItems).distinctBy { it.id }\n        libraryMovies.value = combined\n        filterAndSortLibrary(\"movie\")\n    }\n\n    private fun updateSeriesSource() {\n        val localItems = _localSeriesRaw.value ?: emptyList()\n        val traktItems = if (_isTraktEnabled.value == true) _traktSeriesRaw.value ?: emptyList() else emptyList()\n        val combined = (localItems + traktItems).distinctBy { it.id }\n        librarySeries.value = combined\n        filterAndSortLibrary(\"series\")\n    }\n\n    // === TRAKT AUTHENTICATION ===\n    fun startTraktAuth() {\n        viewModelScope.launch {\n            try {\n                val body = mapOf(\"client_id\" to Secrets.TRAKT_CLIENT_ID)\n                val codeResponse = TraktClient.api.getDeviceCode(body)\n                _traktDeviceCode.postValue(codeResponse)\n                pollTraktToken(codeResponse)\n            } catch (e: Exception) {\n                _error.postValue(\"Trakt Auth Error: ${e.message}\")\n            }\n        }\n    }\n\n    private fun pollTraktToken(codeData: TraktDeviceCodeResponse) {\n        viewModelScope.launch {\n            var attempts = 0\n            val interval = if (codeData.interval > 0) codeData.interval else 5\n            val maxAttempts = codeData.expires_in / interval\n\n            while (attempts < maxAttempts) {\n                delay(interval * 1000L)\n                try {\n                    val body = mapOf(\n                        \"code\" to codeData.device_code,\n                        \"client_id\" to Secrets.TRAKT_CLIENT_ID,\n                        \"client_secret\" to Secrets.TRAKT_CLIENT_SECRET\n                    )\n                    val token = TraktClient.api.getDeviceToken(body)\n\n                    prefsManager.saveTraktTokens(token.access_token, token.refresh_token)\n                    _isTraktEnabled.postValue(true)\n                    _traktDeviceCode.postValue(null)\n\n                    // Auto-sync on successful auth\n                    syncTraktLibrary()\n\n                    // Trigger full setup including lists\n                    performTraktSync(syncHistory = true, syncNextUp = true, syncLists = true, fetchMetadata = false)\n\n                    startPeriodicTraktSync()\n\n                    _actionResult.postValue(ActionResult.Success(\"Trakt connected successfully!\"))\n                    return@launch\n                } catch (e: Exception) {\n                    attempts++\n                }\n            }\n            _error.postValue(\"Trakt Auth Timed Out\")\n        }\n    }\n\n    fun logoutTrakt() {\n        prefsManager.clearTraktData()\n        _isTraktEnabled.postValue(false)\n        _traktMoviesRaw.postValue(emptyList())\n        _traktSeriesRaw.postValue(emptyList())\n        _actionResult.postValue(ActionResult.Success(\"Trakt disconnected\"))\n    }\n\n    // === ENHANCED TRAKT SYNC ===\n    fun syncTraktLibrary() {\n        val token = prefsManager.getTraktAccessToken() ?: return\n        val bearer = \"Bearer $token\"\n        val clientId = Secrets.TRAKT_CLIENT_ID\n\n        _isLoading.postValue(true)\n        viewModelScope.launch {\n            try {\n                // Fetch Movies\n                val movies = TraktClient.api.getMovieCollection(bearer, clientId)\n                val metaMovies = movies.mapNotNull { it.movie }.map { movie ->\n                    MetaItem(\n                        id = \"tmdb:${movie.ids.tmdb}\",\n                        type = \"movie\",\n                        name = movie.title,\n                        poster = null,\n                        background = null,\n                        description = null,\n                        releaseDate = movie.year?.toString()\n                    )\n                }\n                _traktMoviesRaw.postValue(metaMovies)\n\n                // Fetch Shows\n                val shows = TraktClient.api.getShowCollection(bearer, clientId)\n                val metaShows = shows.mapNotNull { it.show }.map { show ->\n                    MetaItem(\n                        id = \"tmdb:${show.ids.tmdb}\",\n                        type = \"series\",\n                        name = show.title,\n                        poster = null,\n                        background = null,\n                        description = null,\n                        releaseDate = show.year?.toString()\n                    )\n                }\n                _traktSeriesRaw.postValue(metaShows)\n\n            } catch (e: Exception) {\n                Log.e(\"Trakt\", \"Sync failed\", e)\n            } finally {\n                _isLoading.postValue(false)\n            }\n        }\n    }\n\n    // === CONTENT LOADING (Refactored) ===\n\n    // Original method used by DiscoverFragment\n    fun loadContentForCatalog(catalog: UserCatalog, isInitialLoad: Boolean = true) {\n        if (apiKey.isEmpty()) return\n\n        _isLoading.postValue(true)\n        if (isInitialLoad) {\n            loadedContentCache.clear()\n            lastRequestedCatalog = catalog\n        }\n\n        viewModelScope.launch {\n            try {\n                val items = fetchCatalogItems(catalog)\n\n                if (isInitialLoad) {\n                    loadedContentCache.addAll(items)\n                    _currentCatalogContent.postValue(loadedContentCache)\n                } else {\n                    _currentCatalogContent.postValue(items)\n                }\n            } catch (e: Exception) {\n                _error.postValue(\"Load failed: ${e.message}\")\n                if (isInitialLoad) {\n                    _currentCatalogContent.postValue(emptyList())\n                }\n            } finally {\n                _isLoading.postValue(false)\n            }\n        }\n    }\n\n    // Load all Home sections in parallel (Called by HomeFragment)\n    fun loadHomeContent() {\n        if (apiKey.isEmpty()) return\n\n        viewModelScope.launch {\n            val userId = prefsManager.getCurrentUserId() ?: \"default\"\n            val isTrakt = prefsManager.isTraktEnabled()\n\n            // Create catalogs on the fly for Home (skipping the filtered DB list)\n            val nextUpCat = if (isTrakt) UserCatalog(0, userId, \"trakt_next_up\", \"series\", \"Next Up\", null, 0, \"series\", \"trakt\", \"trakt_official\", true, true)\n            else UserCatalog(0, userId, \"next_up\", \"series\", \"Next Up\", null, 0, \"series\", \"local\", \"local\", true, true)\n\n            val continueShowCat = if (isTrakt) UserCatalog(0, userId, \"trakt_continue_shows\", \"series\", \"Continue Watching\", null, 0, \"series\", \"trakt\", \"trakt_official\", true, true)\n            else UserCatalog(0, userId, \"continue_episodes\", \"series\", \"Continue Watching\", null, 0, \"series\", \"local\", \"local\", true, true)\n\n            val continueMovieCat = if (isTrakt) UserCatalog(0, userId, \"trakt_continue_movies\", \"movie\", \"Continue Watching\", null, 0, \"movies\", \"trakt\", \"trakt_official\", true, true)\n            else UserCatalog(0, userId, \"continue_movies\", \"movie\", \"Continue Watching\", null, 0, \"movies\", \"local\", \"local\", true, true)\n\n            val nextUpJob = async { fetchCatalogItems(nextUpCat) }\n            val showsJob = async { fetchCatalogItems(continueShowCat) }\n            val moviesJob = async { fetchCatalogItems(continueMovieCat) }\n\n            try {\n                _homeNextUp.postValue(nextUpJob.await())\n                _homeContinueEpisodes.postValue(showsJob.await())\n                _homeContinueMovies.postValue(moviesJob.await())\n            } catch (e: Exception) {\n                Log.e(\"HomeLoad\", \"Error loading home content\", e)\n            }\n        }\n    }\n\n    // Reusable suspended function\n    private suspend fun fetchCatalogItems(catalog: UserCatalog): List<MetaItem> {\n        if (catalog.addonUrl == \"trakt\") {\n            val token = prefsManager.getTraktAccessToken()\n            val clientId = Secrets.TRAKT_CLIENT_ID\n\n            if (token != null) {\n                val bearer = \"Bearer $token\"\n                val items: List<MetaItem> = when (catalog.catalogId) {\n                    \"trakt_next_up\" -> generateNextUpList()\n\n                    \"trakt_continue_movies\" -> {\n                        val list = TraktClient.api.getPausedMovies(bearer, clientId)\n                        list.mapNotNull { it.movie }.map { movie ->\n                            MetaItem(id = \"tmdb:${movie.ids.tmdb}\", type = \"movie\", name = movie.title, description = \"Paused\", poster = null, background = null)\n                        }\n                    }\n\n                    \"trakt_continue_shows\" -> {\n                        val list = TraktClient.api.getPausedEpisodes(bearer, clientId)\n                        list.mapNotNull { item ->\n                            val show = item.show\n                            val ep = item.episode\n                            if (show != null && ep != null) {\n                                val epTmdbId = ep.ids?.tmdb\n                                if (epTmdbId != null) {\n                                    MetaItem(\n                                        id = \"trakt_ep:${show.ids.tmdb}:$epTmdbId\",\n                                        type = \"episode\",\n                                        name = \"${show.title} - ${ep.number}\",\n                                        description = \"Paused at ${(item.progress ?: 0f).toInt()}%\",\n                                        poster = null, background = null\n                                    )\n                                } else null\n                            } else null\n                        }\n                    }\n\n                    \"trakt_watchlist_movies\" -> {\n                        TraktClient.api.getWatchlist(bearer, clientId, type = \"movies\")\n                            .mapNotNull { it.movie }\n                            .map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"movie\", it.title, null, null, null) }\n                    }\n                    \"trakt_watchlist_shows\" -> {\n                        TraktClient.api.getWatchlist(bearer, clientId, type = \"shows\")\n                            .mapNotNull { it.show }\n                            .map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"series\", it.title, null, null, null) }\n                    }\n\n                    \"trakt_popular_movies\" -> TraktClient.api.getPopularMovies(clientId).map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"movie\", it.title, null, null, null) }\n                    \"trakt_popular_shows\" -> TraktClient.api.getPopularShows(clientId).map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"series\", it.title, null, null, null) }\n                    \"trakt_trending_movies\" -> TraktClient.api.getTrendingMovies(clientId).mapNotNull { it.movie }.map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"movie\", it.title, null, null, null) }\n                    \"trakt_trending_shows\" -> TraktClient.api.getTrendingShows(clientId).mapNotNull { it.show }.map { MetaItem(\"tmdb:${it.ids.tmdb}\", \"series\", it.title, null, null, null) }\n\n                    else -> emptyList()\n                }\n\n                return enrichWithTmdbMetadata(items, catalog.catalogId)\n            } else {\n                return emptyList()\n            }\n\n        } else if (catalog.catalogId in listOf(\"popular\", \"latest\", \"trending\")) {\n            val pagesToLoad = listOf(1, 2)\n            val allItems = mutableListOf<MetaItem>()\n\n            val deferredResults = pagesToLoad.map { page ->\n                viewModelScope.async {\n                    try {\n                        if (catalog.catalogType == \"movie\") {\n                            when (catalog.catalogId) {\n                                \"popular\" -> TMDBClient.api.getPopularMovies(apiKey, page = page)\n                                \"latest\" -> TMDBClient.api.getLatestMovies(apiKey, page = page)\n                                else -> TMDBClient.api.getTrendingMovies(apiKey, page = page)\n                            }\n                        } else {\n                            when (catalog.catalogId) {\n                                \"popular\" -> TMDBClient.api.getPopularSeries(apiKey, page = page)\n                                \"latest\" -> TMDBClient.api.getLatestSeries(apiKey, page = page)\n                                else -> TMDBClient.api.getTrendingSeries(apiKey, page = page)\n                            }\n                        }\n                    } catch (e: Exception) { null }\n                }\n            }\n            val results = deferredResults.awaitAll()\n            results.filterNotNull().forEach { response ->\n                val fetchedItems = if (response is TMDBMovieListResponse) {\n                    response.results.map { it.toMetaItem() }\n                } else if (response is TMDBSeriesListResponse) {\n                    response.results.map { it.toMetaItem() }\n                } else { emptyList() }\n                allItems.addAll(fetchedItems)\n            }\n            return allItems\n\n        } else {\n            return when (catalog.catalogId) {\n                \"continue_movies\" -> {\n                    val currentUserId = prefsManager.getCurrentUserId() ?: \"default\"\n                    catalogRepository.getContinueWatching(currentUserId, \"movie\").map { progress ->\n                        MetaItem(id = progress.itemId, type = progress.type, name = progress.name ?: \"Unknown\", poster = progress.poster, background = progress.background, description = null, isWatched = progress.isWatched, progress = progress.progress, duration = progress.duration)\n                    }\n                }\n                \"continue_episodes\" -> {\n                    val currentUserId = prefsManager.getCurrentUserId() ?: \"default\"\n                    catalogRepository.getContinueWatching(currentUserId, \"episode\").map { progress ->\n                        MetaItem(id = progress.itemId, type = progress.type, name = progress.name ?: \"Unknown\", poster = progress.poster, background = progress.background, description = null, isWatched = progress.isWatched, progress = progress.progress, duration = progress.duration)\n                    }\n                }\n                \"next_up\" -> generateNextUpList()\n                else -> emptyList()\n            }\n        }\n    }\n\n    private suspend fun enrichWithTmdbMetadata(items: List<MetaItem>, catalogId: String): List<MetaItem> {\n        return items.map { item ->\n            viewModelScope.async {\n                try {\n                    if (item.id.startsWith(\"trakt_ep:\")) {\n                        val parts = item.id.split(\":\")\n                        val showTmdbId = parts[1].toIntOrNull()\n\n                        if (showTmdbId != null && apiKey.isNotEmpty()) {\n                            val details = TMDBClient.api.getTVDetails(showTmdbId, apiKey)\n                            val poster = details.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }\n                            val background = details.backdrop_path?.let { \"https://image.tmdb.org/t/p/original$it\" }\n\n                            val newId = \"tmdb:$showTmdbId:1:1\"\n\n                            item.copy(\n                                id = newId,\n                                poster = poster,\n                                background = background,\n                                name = \"${details.name} - ${item.name}\",\n                                description = \"${item.description}\\n\\n(Resume info limited)\"\n                            )\n                        } else item\n                    } else {\n                        val parts = item.id.removePrefix(\"tmdb:\").split(\":\")\n                        val tmdbId = parts[0].toIntOrNull()\n\n                        if (tmdbId != null && apiKey.isNotEmpty()) {\n                            if (item.type == \"movie\") {\n                                val details = TMDBClient.api.getMovieDetails(tmdbId, apiKey)\n                                val poster = details.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }\n                                val background = details.backdrop_path?.let { \"https://image.tmdb.org/t/p/original$it\" }\n                                item.copy(poster = poster, background = background, description = details.overview)\n                            } else {\n                                val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)\n                                val poster = details.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }\n                                val background = details.backdrop_path?.let { \"https://image.tmdb.org/t/p/original$it\" }\n                                item.copy(poster = poster, background = background, description = details.overview)\n                            }\n                        } else item\n                    }\n                } catch (e: Exception) { item }\n            }\n        }.awaitAll()\n    }\n\n    // === NEXT UP GENERATION ===\n    private suspend fun generateNextUpList(): List<MetaItem> {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return emptyList()\n        val watchedEpisodes = catalogRepository.getNextUpCandidates(currentUserId)\n        val dateFormat = java.text.SimpleDateFormat(\"yyyy-MM-dd\", java.util.Locale.getDefault())\n        val today = dateFormat.format(java.util.Date())\n\n        val latestEpisodesByShow = watchedEpisodes\n            .filter { it.parentId != null && it.season != null && it.episode != null }\n            .groupBy { it.parentId!! }\n            .mapValues { (_, episodes) ->\n                episodes.maxWithOrNull(compareBy<WatchProgress> { it.season!! }.thenBy { it.episode!! })\n            }\n\n        val nextUpItems = mutableListOf<MetaItem>()\n\n        for ((showId, latestEpisode) in latestEpisodesByShow) {\n            if (latestEpisode == null) continue\n\n            val tmdbId = showId.removePrefix(\"tmdb:\").toIntOrNull() ?: continue\n            val currentSeason = latestEpisode.season!!\n            val currentEpisode = latestEpisode.episode!!\n\n            try {\n                val showDetails = TMDBClient.api.getTVDetails(tmdbId, apiKey)\n                var nextSeasonNum = currentSeason\n                var nextEpisodeNum = currentEpisode + 1\n                var potentialNextFound = false\n\n                val currentSeasonSpec = showDetails.seasons?.find { it.season_number == currentSeason }\n                if (currentSeasonSpec != null && currentEpisode < currentSeasonSpec.episode_count) {\n                    potentialNextFound = true\n                } else {\n                    val nextSeasonSpec = showDetails.seasons?.find { it.season_number == currentSeason + 1 }\n                    if (nextSeasonSpec != null && nextSeasonSpec.episode_count > 0) {\n                        nextSeasonNum = currentSeason + 1\n                        nextEpisodeNum = 1\n                        potentialNextFound = true\n                    }\n                }\n\n                if (potentialNextFound) {\n                    try {\n                        val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, nextSeasonNum, apiKey)\n                        val nextEpDetails = seasonDetails.episodes.find { it.episode_number == nextEpisodeNum }\n\n                        if (nextEpDetails != null) {\n                            val isReleased = nextEpDetails.airDate == null || nextEpDetails.airDate <= today\n\n                            if (isReleased) {\n                                val nextEpisodeId = \"$showId:$nextSeasonNum:$nextEpisodeNum\"\n                                val nextEpisodeProgress = catalogRepository.getWatchProgress(currentUserId, nextEpisodeId)\n\n                                if (nextEpisodeProgress == null || !nextEpisodeProgress.isWatched) {\n                                    val poster = nextEpDetails.still_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }\n                                        ?: showDetails.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }\n\n                                    val background = nextEpDetails.still_path?.let { \"https://image.tmdb.org/t/p/original$it\" }\n                                        ?: showDetails.backdrop_path?.let { \"https://image.tmdb.org/t/p/original$it\" }\n\n                                    nextUpItems.add(\n                                        MetaItem(\n                                            id = nextEpisodeId,\n                                            type = \"episode\",\n                                            name = nextEpDetails.name,\n                                            poster = poster,\n                                            background = background,\n                                            description = nextEpDetails.overview ?: \"Next episode\"\n                                        )\n                                    )\n                                }\n                            }\n                        }\n                    } catch (e: Exception) { Log.e(\"NextUp\", \"Failed season details\", e) }\n                }\n            } catch (e: Exception) { Log.e(\"NextUp\", \"Error processing next episode\", e) }\n        }\n        return nextUpItems\n    }\n\n    // === TRAKT SYNC ===\n    fun performTraktSync(syncHistory: Boolean, syncNextUp: Boolean, syncLists: Boolean, fetchMetadata: Boolean = true) {\n        if (!prefsManager.isTraktEnabled()) return\n\n        _traktSyncStatus.postValue(TraktSyncStatus.Syncing(\"Syncing...\"))\n        viewModelScope.launch {\n            val userId = prefsManager.getCurrentUserId() ?: \"default\"\n            val token = prefsManager.getTraktAccessToken() ?: return@launch\n            val bearer = \"Bearer $token\"\n            val clientId = Secrets.TRAKT_CLIENT_ID\n\n            try {\n                if (syncHistory) {\n                    _traktSyncStatus.postValue(TraktSyncStatus.Syncing(\"Fetching watched history...\"))\n\n                    val watchedMovies = TraktClient.api.getWatchedMovies(bearer, clientId)\n                    watchedMovies.forEach { item ->\n                        item.movie?.ids?.tmdb?.let { tmdbId ->\n                            val meta = MetaItem(\"tmdb:$tmdbId\", \"movie\", item.movie.title, null, null, \"Trakt Import\")\n                            catalogRepository.addToLibrary(CollectedItem.fromMetaItem(userId, meta))\n                            catalogRepository.saveWatchProgress(WatchProgress(userId, meta.id, \"movie\", 0, 0, true, System.currentTimeMillis(), meta.name, null, null, null, null, null))\n                        }\n                    }\n\n                    val watchedShows = TraktClient.api.getWatchedShows(bearer, clientId)\n                    watchedShows.forEach { item ->\n                        item.show?.ids?.tmdb?.let { showTmdbId ->\n                            val seriesMeta = MetaItem(\"tmdb:$showTmdbId\", \"series\", item.show.title, null, null, \"Trakt Import\")\n                            catalogRepository.addToLibrary(CollectedItem.fromMetaItem(userId, seriesMeta))\n\n                            item.seasons?.forEach { season ->\n                                season.episodes.forEach { ep ->\n                                    val epId = \"tmdb:$showTmdbId:${season.number}:${ep.number}\"\n                                    catalogRepository.saveWatchProgress(\n                                        WatchProgress(userId, epId, \"episode\", 0, 0, true, System.currentTimeMillis(),\n                                            \"${item.show.title} S${season.number}E${ep.number}\", null, null, \"tmdb:$showTmdbId\", season.number, ep.number)\n                                    )\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // No need to insert \"Next Up\" or \"Continue Watching\" to DB anymore\n                // They are handled dynamically by HomeFragment.\n                // We only sync lists like Watchlists/Popular to DB for Discover page.\n\n                if (syncLists) {\n                    val catalogs = listOf(\n                        UserCatalog(0, userId, \"trakt_watchlist_movies\", \"movie\", \"Trakt Watchlist\", null, 1, \"movies\", \"trakt\", \"trakt_official\", true, false),\n                        UserCatalog(0, userId, \"trakt_watchlist_shows\", \"series\", \"Trakt Watchlist\", null, 1, \"series\", \"trakt\", \"trakt_official\", true, false),\n                        UserCatalog(0, userId, \"trakt_trending_movies\", \"movie\", \"Trakt Trending\", null, 3, \"movies\", \"trakt\", \"trakt_official\", true, true),\n                        UserCatalog(0, userId, \"trakt_trending_shows\", \"series\", \"Trakt Trending\", null, 3, \"series\", \"trakt\", \"trakt_official\", true, true)\n                    )\n\n                    catalogs.forEach {\n                        if (!catalogRepository.isCatalogAdded(userId, it.catalogId, it.catalogType, it.pageType)) {\n                            catalogRepository.insertCatalog(it)\n                        }\n                    }\n                }\n\n                _traktSyncStatus.postValue(TraktSyncStatus.Success(\"Sync Complete\"))\n\n            } catch (e: Exception) {\n                _traktSyncStatus.postValue(TraktSyncStatus.Error(e.message ?: \"Error\"))\n            } finally {\n                _isLoading.postValue(false)\n            }\n        }\n    }\n\n    private fun startPeriodicTraktSync() {\n        viewModelScope.launch {\n            while (prefsManager.isTraktEnabled()) {\n                delay(30 * 60 * 1000L) // Every 30 minutes\n                syncTraktLibrary()\n            }\n        }\n    }\n\n    // === WATCHED ACTION & REFRESH ===\n    fun markAsWatched(item: MetaItem, syncToTrakt: Boolean = true) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        val idStr = item.id.removePrefix(\"tmdb:\")\n        val tmdbId = idStr.toIntOrNull()\n\n        viewModelScope.launch {\n            try {\n                if (syncToTrakt && prefsManager.isTraktEnabled()) {\n                    val token = prefsManager.getTraktAccessToken()\n                    if (token != null) {\n                        val bearer = \"Bearer $token\"\n                        val body = if (item.type == \"movie\") {\n                            val id = item.id.removePrefix(\"tmdb:\").toIntOrNull()\n                            if (id != null) TraktHistoryBody(movies = listOf(TraktMovie(\"\", null, TraktIds(0, id, null, null)))) else null\n                        } else if (item.type == \"episode\") {\n                            val parts = item.id.split(\":\")\n                            if (parts.size >= 4) {\n                                val e = parts[3].toIntOrNull()\n                                if (e != null) TraktHistoryBody(episodes = listOf(TraktEpisode(e, 1, null, null))) else null\n                            } else null\n                        } else null\n\n                        if (body != null) {\n                            TraktClient.api.addToHistory(bearer, Secrets.TRAKT_CLIENT_ID, body)\n                        }\n                    }\n                }\n\n                if (item.type == \"series\" && tmdbId != null && apiKey.isNotEmpty()) {\n                    val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)\n                    details.seasons?.forEach { season ->\n                        if (season.episode_count > 0) {\n                            val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, season.season_number, apiKey)\n                            seasonDetails.episodes.forEach { ep ->\n                                val epId = \"tmdb:$tmdbId:${ep.season_number}:${ep.episode_number}\"\n                                catalogRepository.saveWatchProgress(WatchProgress(currentUserId, epId, \"episode\", 0, 0, true, System.currentTimeMillis(), \"${details.name} S${season.season_number}E${ep.episode_number}\", null, null, \"tmdb:$tmdbId\", season.season_number, ep.episode_number))\n                            }\n                        }\n                    }\n                } else if (item.type == \"episode\") {\n                    val parts = item.id.split(\":\")\n                    if (parts.size >= 4) {\n                        val parentId = \"${parts[0]}:${parts[1]}\"\n                        val s = parts[2].toIntOrNull()\n                        val e = parts[3].toIntOrNull()\n                        catalogRepository.saveWatchProgress(WatchProgress(currentUserId, item.id, \"episode\", 0, 0, true, System.currentTimeMillis(), item.name, item.poster, item.background, parentId, s, e))\n                    }\n                } else {\n                    catalogRepository.saveWatchProgress(WatchProgress(currentUserId, item.id, item.type, 0, 0, true, System.currentTimeMillis(), item.name, item.poster, item.background, null, null, null))\n                }\n\n                // Refresh\n                lastRequestedCatalog?.let {\n                    loadContentForCatalog(it, isInitialLoad = false)\n                }\n                // Also reload home if needed\n                loadHomeContent()\n\n                _isItemWatched.postValue(true)\n                _actionResult.postValue(ActionResult.Success(\"Marked as watched\"))\n\n            } catch (e: Exception) {\n                _actionResult.postValue(ActionResult.Error(\"Failed: ${e.message}\"))\n            }\n        }\n    }\n\n    fun clearWatchedStatus(item: MetaItem, syncToTrakt: Boolean = true) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        val tmdbId = item.id.removePrefix(\"tmdb:\").split(\":\")[0].toIntOrNull()\n\n        viewModelScope.launch {\n            try {\n                if (syncToTrakt && prefsManager.isTraktEnabled() && tmdbId != null) {\n                    val token = prefsManager.getTraktAccessToken()\n                    if (token != null) {\n                        val bearer = \"Bearer $token\"\n                        val body = if (item.type == \"movie\") {\n                            TraktHistoryBody(movies = listOf(TraktMovie(\"\", null, TraktIds(0, tmdbId, null, null))))\n                        } else null\n\n                        if (body != null) TraktClient.api.removeFromHistory(bearer, Secrets.TRAKT_CLIENT_ID, body)\n                    }\n                }\n\n                catalogRepository.updateWatchedStatus(currentUserId, item.id, false)\n                lastRequestedCatalog?.let { loadContentForCatalog(it, isInitialLoad = false) }\n                loadHomeContent()\n\n                _isItemWatched.postValue(false)\n                _actionResult.postValue(ActionResult.Success(\"Cleared watched status\"))\n            } catch (e: Exception) {\n                _actionResult.postValue(ActionResult.Error(\"Failed: ${e.message}\"))\n            }\n        }\n    }\n\n    // === STANDARD METHODS ===\n    fun loadStreams(type: String, itemId: String) {\n        _isLoading.postValue(true)\n        viewModelScope.launch {\n            val allStreams = mutableListOf<Stream>()\n            val aioUsername = prefsManager.getAIOStreamsUsername()\n            val aioPassword = prefsManager.getAIOStreamsPassword()\n            val aioUrl = prefsManager.getAIOStreamsUrl() ?: \"https://aiostreams.shiggsy.co.uk\"\n\n            if (!aioUsername.isNullOrEmpty() && !aioPassword.isNullOrEmpty()) {\n                try {\n                    val aioApi = AIOStreamsClient.getApi(aioUrl, aioUsername, aioPassword)\n                    val aioResponse = aioApi.searchStreams(type, itemId)\n                    if (aioResponse.success && aioResponse.data != null) {\n                        allStreams.addAll(aioResponse.data.results)\n                    }\n                } catch (e: Exception) { Log.e(\"MainViewModel\", \"AIOStreams error\", e) }\n            }\n            _streams.postValue(allStreams)\n            _isLoading.postValue(false)\n        }\n    }\n\n    fun loadEpisodeStreams(seriesId: String, season: Int, episode: Int) {\n        val episodeId = \"$seriesId:$season:$episode\"\n        loadStreams(\"series\", episodeId)\n    }\n\n    fun loadSeriesMeta(itemId: String) {\n        if (apiKey.isEmpty()) return\n        viewModelScope.launch {\n            try {\n                val tmdbId = itemId.removePrefix(\"tmdb:\").toIntOrNull() ?: return@launch\n                val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)\n                val meta = Meta(\n                    id = itemId,\n                    type = \"series\",\n                    name = details.name,\n                    poster = details.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" },\n                    background = details.backdrop_path?.let { \"https://image.tmdb.org/t/p/original$it\" },\n                    description = details.overview,\n                    videos = details.seasons?.map { season ->\n                        Video(season.id.toString(), season.name, null, season.poster_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }, null, season.season_number)\n                    }\n                )\n                _metaDetails.postValue(meta)\n            } catch (e: Exception) { _error.postValue(\"Failed to load series details: ${e.message}\") }\n        }\n    }\n\n    fun loadSeasonEpisodes(seriesId: String, seasonNumber: Int) {\n        if (apiKey.isEmpty()) return\n        viewModelScope.launch {\n            try {\n                val tmdbId = seriesId.removePrefix(\"tmdb:\").toIntOrNull() ?: return@launch\n                val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, seasonNumber, apiKey)\n                val episodes = seasonDetails.episodes.map { episode ->\n                    MetaItem(\n                        id = \"tmdb:$tmdbId:${episode.season_number}:${episode.episode_number}\",\n                        type = \"episode\",\n                        name = episode.name,\n                        poster = episode.still_path?.let { \"https://image.tmdb.org/t/p/w500$it\" },\n                        background = null,\n                        description = episode.overview\n                    )\n                }\n                _seasonEpisodes.postValue(episodes)\n            } catch (e: Exception) { _error.postValue(\"Failed to load season episodes: ${e.message}\") }\n        }\n    }\n\n    fun fetchCast(itemId: String, type: String) {\n        if (apiKey.isEmpty()) return\n        viewModelScope.launch {\n            try {\n                val tmdbId = itemId.removePrefix(\"tmdb:\").toIntOrNull() ?: return@launch\n                val credits = if (type == \"movie\") TMDBClient.api.getMovieCredits(tmdbId, apiKey) else TMDBClient.api.getTVCredits(tmdbId, apiKey)\n                val cast = credits.cast.take(10).map { member ->\n                    MetaItem(\"tmdb:${member.id}\", \"person\", member.name, member.profile_path?.let { \"https://image.tmdb.org/t/p/w500$it\" }, null, member.character)\n                }\n                val director = credits.crew.find { it.job == \"Director\" }?.let { member ->\n                    MetaItem(\"tmdb:${member.id}\", \"person\", member.name, null, null, \"Director\")\n                }\n                _castList.postValue(cast)\n                _director.postValue(director)\n            } catch (e: Exception) { Log.e(\"MainViewModel\", \"Failed to fetch cast\", e) }\n        }\n    }\n\n    fun checkWatchedStatus(itemId: String) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            val progress = catalogRepository.getWatchProgress(currentUserId, itemId)\n            _isItemWatched.postValue(progress?.isWatched ?: false)\n        }\n    }\n\n    fun saveWatchProgress(meta: MetaItem, currentPos: Long, duration: Long) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            val parts = meta.id.split(\":\")\n            val parentId = if (parts.size >= 3) \"${parts[0]}:${parts[1]}\" else null\n            val season = if (parts.size >= 3) parts[2].toIntOrNull() else null\n            val episode = if (parts.size >= 4) parts[3].toIntOrNull() else null\n\n            val progress = WatchProgress(\n                userId = currentUserId,\n                itemId = meta.id,\n                type = meta.type,\n                progress = currentPos,\n                duration = duration,\n                isWatched = currentPos >= duration * 0.9,\n                lastUpdated = System.currentTimeMillis(),\n                name = meta.name,\n                poster = meta.poster,\n                background = meta.background,\n                parentId = parentId,\n                season = season,\n                episode = episode\n            )\n            catalogRepository.saveWatchProgress(progress)\n        }\n    }\n\n    fun searchTMDB(query: String) {\n        if (apiKey.isEmpty() || query.isBlank()) return\n        _isSearching.postValue(true)\n        viewModelScope.launch {\n            try {\n                val response = TMDBClient.api.searchMulti(apiKey, query)\n                val results = response.results.filter { it.media_type == \"movie\" || it.media_type == \"tv\" }.map { it.toMetaItem() }\n                _searchResults.postValue(results)\n            } catch (e: Exception) {\n                _error.postValue(\"Search failed: ${e.message}\")\n                _searchResults.postValue(emptyList())\n            } finally { _isSearching.postValue(false) }\n        }\n    }\n\n    fun searchMovies(query: String) {\n        if (apiKey.isEmpty() || query.isBlank()) return\n        _isSearching.postValue(true)\n        viewModelScope.launch {\n            try {\n                val response = TMDBClient.api.searchMovies(apiKey, query)\n                val results = response.results.map { it.toMetaItem() }\n                _searchResults.postValue(results)\n            } catch (e: Exception) {\n                _error.postValue(\"Movie search failed: ${e.message}\")\n                _searchResults.postValue(emptyList())\n            } finally { _isSearching.postValue(false) }\n        }\n    }\n\n    fun searchSeries(query: String) {\n        if (apiKey.isEmpty() || query.isBlank()) return\n        _isSearching.postValue(true)\n        viewModelScope.launch {\n            try {\n                val response = TMDBClient.api.searchSeries(apiKey, query)\n                val results = response.results.map { it.toMetaItem() }\n                _searchResults.postValue(results)\n            } catch (e: Exception) {\n                _error.postValue(\"Series search failed: ${e.message}\")\n                _searchResults.postValue(emptyList())\n            } finally { _isSearching.postValue(false) }\n        }\n    }\n\n    fun loadPersonCredits(personId: Int) {\n        if (apiKey.isEmpty()) return\n        _isSearching.postValue(true)\n        viewModelScope.launch {\n            try {\n                val response = TMDBClient.api.getPersonCombinedCredits(personId, apiKey)\n                val results = response.cast.map { it.toMetaItem() }\n                _searchResults.postValue(results)\n            } catch (e: Exception) {\n                _error.postValue(\"Person credits failed: ${e.message}\")\n                _searchResults.postValue(emptyList())\n            } finally { _isSearching.postValue(false) }\n        }\n    }\n\n    fun clearSearchResults() { _searchResults.postValue(emptyList()) }\n\n    fun toggleWatchlist(meta: MetaItem, force: Boolean = false) {\n        if (apiKey.isEmpty()) return\n        val sessionId = prefsManager.getTMDBSessionId()\n        val accountId = prefsManager.getTMDBAccountId()\n        if (sessionId.isNullOrEmpty() || accountId == -1) return\n\n        viewModelScope.launch {\n            try {\n                val tmdbId = meta.id.removePrefix(\"tmdb:\").toIntOrNull() ?: return@launch\n                val mediaType = if (meta.type == \"series\") \"tv\" else \"movie\"\n                val isCurrentlyInWatchlist = _isItemInWatchlist.value ?: false\n                val body = TMDBWatchlistBody(mediaType, tmdbId, if (force) true else !isCurrentlyInWatchlist)\n                TMDBClient.api.addToWatchlist(accountId, apiKey, sessionId, body)\n                _isItemInWatchlist.postValue(if (force) true else !isCurrentlyInWatchlist)\n                _actionResult.postValue(ActionResult.Success(\"Watchlist updated\"))\n            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error(\"Watchlist operation failed: ${e.message}\")) }\n        }\n    }\n\n    fun checkLibraryStatus(itemId: String) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            val isCollected = catalogRepository.isItemCollected(itemId, currentUserId)\n            _isItemInLibrary.postValue(isCollected)\n        }\n    }\n\n    fun checkWatchlistStatus(itemId: String, type: String) { _isItemInWatchlist.postValue(false) }\n\n    fun fetchRequestToken() {\n        if (apiKey.isEmpty()) return\n        viewModelScope.launch {\n            try {\n                val response = TMDBClient.api.createRequestToken(apiKey)\n                if (response.success) _requestToken.postValue(response.requestToken)\n                else _error.postValue(\"Failed to create TMDB request token\")\n            } catch (e: Exception) { _error.postValue(\"TMDB Auth error: ${e.message}\") }\n        }\n    }\n\n    fun createSession(requestToken: String) {\n        if (apiKey.isEmpty()) return\n        viewModelScope.launch {\n            try {\n                val body = mapOf(\"request_token\" to requestToken)\n                val response = TMDBClient.api.createSession(apiKey, body)\n                if (response.success) {\n                    prefsManager.saveTMDBSessionId(response.sessionId)\n                    _sessionId.postValue(response.sessionId)\n                    val account = TMDBClient.api.getAccountDetails(apiKey, response.sessionId)\n                    prefsManager.saveTMDBAccountId(account.id)\n                    _actionResult.postValue(ActionResult.Success(\"TMDB connected successfully\"))\n                } else { _error.postValue(\"Failed to create TMDB session\") }\n            } catch (e: Exception) { _error.postValue(\"TMDB Session error: ${e.message}\") }\n        }\n    }\n\n    fun checkTMDBAuthAndSync() {\n        val sessionId = prefsManager.getTMDBSessionId()\n        if (!sessionId.isNullOrEmpty() && apiKey.isNotEmpty()) _sessionId.postValue(sessionId)\n    }\n\n    fun initUserLists() {\n        viewModelScope.launch { catalogRepository.ensureUserListCatalogs(prefsManager.getCurrentUserId() ?: \"default\") }\n    }\n\n    fun initDefaultCatalogs() {\n        viewModelScope.launch { catalogRepository.initializeDefaultsIfNeeded() }\n    }\n\n    fun updateCatalogConfig(catalog: UserCatalog) {\n        viewModelScope.launch { catalogRepository.updateCatalog(catalog) }\n    }\n\n    fun swapCatalogOrder(catalog1: UserCatalog, catalog2: UserCatalog) {\n        viewModelScope.launch { catalogRepository.swapOrder(catalog1, catalog2) }\n    }\n\n    fun getDiscoverCatalogs(type: String): LiveData<List<UserCatalog>> {\n        // The 'allCatalogConfigs' source is already filtered to exclude Home items\n        // So we just need to check the type and 'showInDiscover'\n        return allCatalogConfigs.map { list ->\n            list.filter { cat ->\n                cat.catalogType == type && cat.showInDiscover\n            }.sortedBy { it.displayOrder }\n        }\n    }\n\n    fun filterAndSortLibrary(type: String, genre: String? = null, sortBy: String = \"dateAdded\", ascending: Boolean = false) {\n        viewModelScope.launch {\n            val rawItems = if (type == \"movie\") libraryMovies.value else librarySeries.value\n            if (rawItems == null) return@launch\n            val filtered = rawItems\n            val sorted = when (sortBy) {\n                \"dateAdded\" -> if (ascending) filtered else filtered.reversed()\n                \"releaseDate\" -> if (ascending) filtered.sortedBy { it.releaseDate ?: \"\" } else filtered.sortedByDescending { it.releaseDate ?: \"\" }\n                \"title\" -> if (ascending) filtered.sortedBy { it.name } else filtered.sortedByDescending { it.name }\n                else -> filtered\n            }\n            if (type == \"movie\") _filteredLibraryMovies.postValue(sorted) else _filteredLibrarySeries.postValue(sorted)\n        }\n    }\n\n    fun addToLibrary(meta: MetaItem, syncToTrakt: Boolean = true) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            try {\n                val item = CollectedItem.fromMetaItem(currentUserId, meta)\n                catalogRepository.addToLibrary(item)\n                _isItemInLibrary.postValue(true)\n                if (syncToTrakt && prefsManager.isTraktEnabled()) {\n                    // Sync logic omitted\n                }\n                _actionResult.postValue(ActionResult.Success(\"Added to library\"))\n            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error(\"Failed to add to library: ${e.message}\")) }\n        }\n    }\n\n    fun removeFromLibrary(itemId: String, syncToTrakt: Boolean = true) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            try {\n                catalogRepository.removeFromLibrary(itemId, currentUserId)\n                _isItemInLibrary.postValue(false)\n                _actionResult.postValue(ActionResult.Success(\"Removed from library\"))\n            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error(\"Failed to remove from library: ${e.message}\")) }\n        }\n    }\n\n    fun toggleLibrary(meta: MetaItem) {\n        val currentUserId = prefsManager.getCurrentUserId() ?: return\n        viewModelScope.launch {\n            if (catalogRepository.isItemCollected(meta.id, currentUserId)) removeFromLibrary(meta.id) else addToLibrary(meta)\n        }\n    }\n\n    fun scrobble(action: String, meta: MetaItem, progress: Float) {\n        if (!prefsManager.isTraktEnabled()) return\n        val token = prefsManager.getTraktAccessToken() ?: return\n        val clientId = Secrets.TRAKT_CLIENT_ID\n        viewModelScope.launch {\n            try {\n                val idStr = meta.id.removePrefix(\"tmdb:\")\n                val tmdbId = if (meta.type == \"movie\" || meta.type == \"series\") idStr.toIntOrNull() else 0\n                val body: TraktScrobbleBody? = if (meta.type == \"movie\" && tmdbId != null) {\n                    TraktScrobbleBody(progress, TraktMovie(meta.name, null, TraktIds(0, tmdbId, null, null)))\n                } else if (meta.type == \"episode\") {\n                    val parts = meta.id.split(\":\")\n                    if (parts.size >= 4) {\n                        val showId = parts[1].toIntOrNull()\n                        val s = parts[2].toIntOrNull()\n                        val e = parts[3].toIntOrNull()\n                        if (showId != null && s != null && e != null) {\n                            TraktScrobbleBody(progress, episode = TraktEpisode(s, e), show = TraktShow(meta.name, null, TraktIds(0, showId, null, null)))\n                        } else null\n                    } else null\n                } else null\n\n                if (body != null) {\n                    val bearer = \"Bearer $token\"\n                    when (action) {\n                        \"start\" -> TraktClient.api.startScrobble(bearer, clientId, body = body)\n                        \"pause\" -> TraktClient.api.pauseScrobble(bearer, clientId, body = body)\n                        \"stop\" -> TraktClient.api.stopScrobble(bearer, clientId, body = body)\n                    }\n                }\n            } catch (e: Exception) { Log.e(\"Trakt\", \"Scrobble failed\", e) }\n        }\n    }\n\n    fun fetchItemLogo(meta: MetaItem) {\n        logoFetchJob?.cancel()\n        _currentLogo.value = \"\"\n        logoFetchJob = viewModelScope.launch {\n            try {\n                val idParts = meta.id.removePrefix(\"tmdb:\").split(\":\")\n                val tmdbId = idParts[0].toIntOrNull()\n                if (tmdbId != null && apiKey.isNotEmpty()) {\n                    val images = if (meta.type == \"movie\") TMDBClient.api.getMovieImages(tmdbId, apiKey) else TMDBClient.api.getTVImages(tmdbId, apiKey)\n                    val logo = images.logos.firstOrNull()\n                    _currentLogo.postValue(logo?.let { \"https://image.tmdb.org/t/p/w300${it.file_path}\" })\n                } else { _currentLogo.postValue(null) }\n            } catch (e: Exception) { _currentLogo.postValue(null) }\n        }\n    }\n\n    sealed class TraktSyncStatus {\n        object Idle : TraktSyncStatus()\n        data class Syncing(val progress: String) : TraktSyncStatus()\n        data class Success(val message: String) : TraktSyncStatus()\n        data class Error(val message: String) : TraktSyncStatus()\n    }\n\n    sealed class ActionResult {\n        data class Success(val message: String) : ActionResult()\n        data class Error(val message: String) : ActionResult()\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt b/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt
--- a/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ b/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt	(date 1763934117659)
@@ -8,8 +8,13 @@
 import androidx.lifecycle.map
 import androidx.lifecycle.viewModelScope
 import com.example.stremiompvplayer.CatalogRepository
-import com.example.stremiompvplayer.models.*
-import com.example.stremiompvplayer.network.*
+import com.example.stremiompvplayer.models.Meta
+import com.example.stremiompvplayer.models.MetaItem
+import com.example.stremiompvplayer.models.Stream
+import com.example.stremiompvplayer.models.UserCatalog
+import com.example.stremiompvplayer.network.TMDBClient
+import com.example.stremiompvplayer.network.TraktClient
+import com.example.stremiompvplayer.network.TraktDeviceCodeResponse
 import com.example.stremiompvplayer.utils.Secrets
 import com.example.stremiompvplayer.utils.SharedPreferencesManager
 import kotlinx.coroutines.Job
@@ -17,6 +22,20 @@
 import kotlinx.coroutines.awaitAll
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.launch
+import com.example.stremiompvplayer.network.TraktIds
+import com.example.stremiompvplayer.network.TraktMovie
+import com.example.stremiompvplayer.models.CollectedItem
+import com.example.stremiompvplayer.models.TMDBMovieListResponse
+import com.example.stremiompvplayer.models.TMDBSeriesListResponse
+import com.example.stremiompvplayer.models.WatchProgress
+import com.example.stremiompvplayer.network.TraktHistoryBody
+import com.example.stremiompvplayer.network.TraktShow
+import com.example.stremiompvplayer.network.TraktScrobbleBody
+import com.example.stremiompvplayer.network.TraktEpisode
+import com.example.stremiompvplayer.models.Video
+import com.example.stremiompvplayer.models.TMDBWatchlistBody
+import com.example.stremiompvplayer.network.AIOStreamsClient
+
 
 class MainViewModel(
     private val catalogRepository: CatalogRepository,
Index: app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt b/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt
deleted file mode 100644
--- a/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ /dev/null	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
@@ -1,1209 +0,0 @@
-package com.example.stremiompvplayer.viewmodels
-
-import android.util.Log
-import androidx.lifecycle.LiveData
-import androidx.lifecycle.MediatorLiveData
-import androidx.lifecycle.MutableLiveData
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.map
-import androidx.lifecycle.viewModelScope
-import com.example.stremiompvplayer.CatalogRepository
-import com.example.stremiompvplayer.models.*
-import com.example.stremiompvplayer.network.*
-import com.example.stremiompvplayer.utils.Secrets
-import com.example.stremiompvplayer.utils.SharedPreferencesManager
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.async
-import kotlinx.coroutines.awaitAll
-import kotlinx.coroutines.delay
-import kotlinx.coroutines.launch
-
-class MainViewModel(
-    private val catalogRepository: CatalogRepository,
-    private val prefsManager: SharedPreferencesManager
-) : ViewModel() {
-
-    // --- Core LiveData ---
-    private val _currentCatalogContent = MutableLiveData<List<MetaItem>>()
-    val currentCatalogContent: LiveData<List<MetaItem>> = _currentCatalogContent
-
-    private val _currentLogo = MutableLiveData<String?>()
-    val currentLogo: LiveData<String?> = _currentLogo
-    private var logoFetchJob: Job? = null
-
-    private val apiKey: String get() = prefsManager.getTMDBApiKey() ?: ""
-
-    // Track current catalog to allow refreshing
-    private var lastRequestedCatalog: UserCatalog? = null
-    private var loadedContentCache: MutableList<MetaItem> = mutableListOf()
-
-    val allCatalogConfigs: LiveData<List<UserCatalog>> = catalogRepository.allCatalogs
-    val movieCatalogs = allCatalogConfigs.map { it.filter { c -> c.catalogType == "movie" && c.showInUser }.sortedBy { c -> c.displayOrder } }
-    val seriesCatalogs = allCatalogConfigs.map { it.filter { c -> c.catalogType == "series" && c.showInUser }.sortedBy { c -> c.displayOrder } }
-
-    // UI State
-    private val _streams = MutableLiveData<List<Stream>>()
-    val streams: LiveData<List<Stream>> = _streams
-    private val _metaDetails = MutableLiveData<Meta?>()
-    val metaDetails: LiveData<Meta?> = _metaDetails
-    private val _seasonEpisodes = MutableLiveData<List<MetaItem>>()
-    val seasonEpisodes: LiveData<List<MetaItem>> = _seasonEpisodes
-    private val _castList = MutableLiveData<List<MetaItem>>()
-    val castList: LiveData<List<MetaItem>> = _castList
-    private val _director = MutableLiveData<MetaItem?>()
-    val director: LiveData<MetaItem?> = _director
-    private val _error = MutableLiveData<String>()
-    val error: LiveData<String> = _error
-    private val _isLoading = MutableLiveData<Boolean>()
-    val isLoading: LiveData<Boolean> = _isLoading
-    private val _actionResult = MutableLiveData<ActionResult>()
-    val actionResult: LiveData<ActionResult> = _actionResult
-
-    // Trakt State
-    private val _traktDeviceCode = MutableLiveData<TraktDeviceCodeResponse?>()
-    val traktDeviceCode: LiveData<TraktDeviceCodeResponse?> = _traktDeviceCode
-    private val _isTraktEnabled = MutableLiveData<Boolean>(prefsManager.isTraktEnabled())
-    val isTraktEnabled: LiveData<Boolean> = _isTraktEnabled
-    private val _traktSyncProgress = MutableLiveData<String>()
-    val traktSyncProgress: LiveData<String> = _traktSyncProgress
-    private val _traktSyncStatus = MutableLiveData<TraktSyncStatus>()
-    val traktSyncStatus: LiveData<TraktSyncStatus> = _traktSyncStatus
-
-    // Library Sources (Local + Trakt)
-    val libraryMovies = MediatorLiveData<List<MetaItem>>()
-    val librarySeries = MediatorLiveData<List<MetaItem>>()
-
-    private val _localMoviesRaw = catalogRepository.getLibraryItems(prefsManager.getCurrentUserId() ?: "default", "movie").map { items ->
-        items.map { toMetaItem(it) }
-    }
-    private val _localSeriesRaw = catalogRepository.getLibraryItems(prefsManager.getCurrentUserId() ?: "default", "series").map { items ->
-        items.map { toMetaItem(it) }
-    }
-
-    private val _traktMoviesRaw = MutableLiveData<List<MetaItem>>()
-    private val _traktSeriesRaw = MutableLiveData<List<MetaItem>>()
-
-    // Filtered library for UI
-    private val _filteredLibraryMovies = MutableLiveData<List<MetaItem>>()
-    val filteredLibraryMovies: LiveData<List<MetaItem>> = _filteredLibraryMovies
-
-    private val _filteredLibrarySeries = MutableLiveData<List<MetaItem>>()
-    val filteredLibrarySeries: LiveData<List<MetaItem>> = _filteredLibrarySeries
-
-    // Library Status Checks
-    private val _isItemInWatchlist = MutableLiveData<Boolean>(false)
-    val isItemInWatchlist: LiveData<Boolean> = _isItemInWatchlist
-    private val _isItemInLibrary = MutableLiveData<Boolean>(false)
-    val isItemInLibrary: LiveData<Boolean> = _isItemInLibrary
-    private val _isItemWatched = MutableLiveData<Boolean>(false)
-    val isItemWatched: LiveData<Boolean> = _isItemWatched
-
-    // Search & Auth
-    private val _searchResults = MutableLiveData<List<MetaItem>>()
-    val searchResults: LiveData<List<MetaItem>> = _searchResults
-    private val _isSearching = MutableLiveData<Boolean>()
-    val isSearching: LiveData<Boolean> = _isSearching
-    private val _requestToken = MutableLiveData<String?>()
-    val requestToken: LiveData<String?> = _requestToken
-    private val _sessionId = MutableLiveData<String?>()
-    val sessionId: LiveData<String?> = _sessionId
-
-    init {
-        setupLibrarySources()
-        initDefaultCatalogs()
-        initUserLists()
-        if (prefsManager.isTraktEnabled()) {
-            syncTraktLibrary()
-            startPeriodicTraktSync()
-        }
-    }
-
-    // === HELPER FUNCTIONS ===
-    private fun toMetaItem(item: CollectedItem): MetaItem {
-        return MetaItem(item.itemId, item.itemType, item.name, item.poster, item.background, item.description)
-    }
-
-    // === LIBRARY SOURCE MANAGEMENT ===
-    private fun setupLibrarySources() {
-        libraryMovies.addSource(_isTraktEnabled) { updateMovieSource() }
-        libraryMovies.addSource(_localMoviesRaw) { updateMovieSource() }
-        libraryMovies.addSource(_traktMoviesRaw) { updateMovieSource() }
-
-        librarySeries.addSource(_isTraktEnabled) { updateSeriesSource() }
-        librarySeries.addSource(_localSeriesRaw) { updateSeriesSource() }
-        librarySeries.addSource(_traktSeriesRaw) { updateSeriesSource() }
-    }
-
-    private fun updateMovieSource() {
-        val localItems = _localMoviesRaw.value ?: emptyList()
-        val traktItems = if (_isTraktEnabled.value == true) _traktMoviesRaw.value ?: emptyList() else emptyList()
-        val combined = (localItems + traktItems).distinctBy { it.id }
-        libraryMovies.value = combined
-        filterAndSortLibrary("movie")
-    }
-
-    private fun updateSeriesSource() {
-        val localItems = _localSeriesRaw.value ?: emptyList()
-        val traktItems = if (_isTraktEnabled.value == true) _traktSeriesRaw.value ?: emptyList() else emptyList()
-        val combined = (localItems + traktItems).distinctBy { it.id }
-        librarySeries.value = combined
-        filterAndSortLibrary("series")
-    }
-
-    // === TRAKT AUTHENTICATION ===
-    fun startTraktAuth() {
-        viewModelScope.launch {
-            try {
-                val body = mapOf("client_id" to Secrets.TRAKT_CLIENT_ID)
-                val codeResponse = TraktClient.api.getDeviceCode(body)
-                _traktDeviceCode.postValue(codeResponse)
-                pollTraktToken(codeResponse)
-            } catch (e: Exception) {
-                _error.postValue("Trakt Auth Error: ${e.message}")
-            }
-        }
-    }
-
-    private fun pollTraktToken(codeData: TraktDeviceCodeResponse) {
-        viewModelScope.launch {
-            var attempts = 0
-            val interval = if (codeData.interval > 0) codeData.interval else 5
-            val maxAttempts = codeData.expires_in / interval
-
-            while (attempts < maxAttempts) {
-                delay(interval * 1000L)
-                try {
-                    val body = mapOf(
-                        "code" to codeData.device_code,
-                        "client_id" to Secrets.TRAKT_CLIENT_ID,
-                        "client_secret" to Secrets.TRAKT_CLIENT_SECRET
-                    )
-                    val token = TraktClient.api.getDeviceToken(body)
-
-                    prefsManager.saveTraktTokens(token.access_token, token.refresh_token)
-                    _isTraktEnabled.postValue(true)
-                    _traktDeviceCode.postValue(null)
-
-                    // Auto-sync on successful auth
-                    syncTraktLibrary()
-
-                    // Trigger full setup including lists
-                    performTraktSync(syncHistory = true, syncNextUp = true, syncLists = true, fetchMetadata = false)
-
-                    startPeriodicTraktSync()
-
-                    _actionResult.postValue(ActionResult.Success("Trakt connected successfully!"))
-                    return@launch
-                } catch (e: Exception) {
-                    attempts++
-                }
-            }
-            _error.postValue("Trakt Auth Timed Out")
-        }
-    }
-
-    fun logoutTrakt() {
-        prefsManager.clearTraktData()
-        _isTraktEnabled.postValue(false)
-        _traktMoviesRaw.postValue(emptyList())
-        _traktSeriesRaw.postValue(emptyList())
-        _actionResult.postValue(ActionResult.Success("Trakt disconnected"))
-    }
-
-    // === ENHANCED TRAKT SYNC ===
-    fun syncTraktLibrary() {
-        val token = prefsManager.getTraktAccessToken() ?: return
-        val bearer = "Bearer $token"
-        val clientId = Secrets.TRAKT_CLIENT_ID
-
-        _isLoading.postValue(true)
-        viewModelScope.launch {
-            try {
-                // Fetch Movies
-                val movies = TraktClient.api.getMovieCollection(bearer, clientId)
-                val metaMovies = movies.mapNotNull { it.movie }.map { movie ->
-                    MetaItem(
-                        id = "tmdb:${movie.ids.tmdb}",
-                        type = "movie",
-                        name = movie.title,
-                        poster = null,
-                        background = null,
-                        description = null,
-                        releaseDate = movie.year?.toString()
-                    )
-                }
-                _traktMoviesRaw.postValue(metaMovies)
-
-                // Fetch Shows
-                val shows = TraktClient.api.getShowCollection(bearer, clientId)
-                val metaShows = shows.mapNotNull { it.show }.map { show ->
-                    MetaItem(
-                        id = "tmdb:${show.ids.tmdb}",
-                        type = "series",
-                        name = show.title,
-                        poster = null,
-                        background = null,
-                        description = null,
-                        releaseDate = show.year?.toString()
-                    )
-                }
-                _traktSeriesRaw.postValue(metaShows)
-
-            } catch (e: Exception) {
-                Log.e("Trakt", "Sync failed", e)
-            } finally {
-                _isLoading.postValue(false)
-            }
-        }
-    }
-
-    // === CONTENT LOADING (Updated for Trakt Split) ===
-
-    fun loadContentForCatalog(catalog: UserCatalog, isInitialLoad: Boolean = true) {
-        if (apiKey.isEmpty()) return
-
-        _isLoading.postValue(true)
-        if (isInitialLoad) {
-            loadedContentCache.clear()
-            lastRequestedCatalog = catalog
-        }
-
-        viewModelScope.launch {
-            try {
-                if (catalog.addonUrl == "trakt") {
-                    val token = prefsManager.getTraktAccessToken()
-                    val clientId = Secrets.TRAKT_CLIENT_ID
-
-                    if (token != null) {
-                        val bearer = "Bearer $token"
-                        val items: List<MetaItem> = when (catalog.catalogId) {
-
-                            // 1. TRAKT NEXT UP (Series Only - Uses local history synced from Trakt)
-                            "trakt_next_up" -> generateNextUpList()
-
-                            // 2. CONTINUE WATCHING (Movies)
-                            "trakt_continue_movies" -> {
-                                val list = TraktClient.api.getPausedMovies(bearer, clientId)
-                                list.mapNotNull { it.movie }.map { movie ->
-                                    MetaItem(
-                                        id = "tmdb:${movie.ids.tmdb}",
-                                        type = "movie",
-                                        name = movie.title,
-                                        description = "Paused",
-                                        poster = null, background = null
-                                    )
-                                }
-                            }
-
-                            // 3. CONTINUE WATCHING (Series/Episodes)
-                            "trakt_continue_shows" -> {
-                                val list = TraktClient.api.getPausedEpisodes(bearer, clientId)
-                                list.mapNotNull { item ->
-                                    val show = item.show
-                                    val ep = item.episode
-                                    if (show != null && ep != null) {
-                                        // We need a valid Episode ID format: tmdb:SHOW_ID:SEASON:EPISODE
-                                        // Trakt's 'episode' object usually contains season and number.
-                                        // However, the Playback endpoint might return a slightly different structure.
-                                        // We will construct a temporary ID and enrich it.
-
-                                        // Assuming simple structure for now, relying on enrichment to get details
-                                        // If episode.season is missing here, we might need a fallback or fetch
-                                        val seasonNum = ep.number // wait, ep.number is usually episode number.
-                                        // TraktEpisode data class: val number: Int. Does it have season?
-                                        // The data class in TraktClient.kt defines TraktEpisode as:
-                                        // data class TraktEpisode(val number: Int, val plays: Int = 0, val last_watched_at: String? = null, val ids: TraktIds? = null)
-                                        // It DOES NOT have season number directly unless nested in a season object.
-
-                                        // FIX: TraktPausedItem -> episode might not have season.
-                                        // We will use a special ID format "trakt_paused:SHOW_ID:EP_ID" and handle in enrichment?
-                                        // Or better: The TMDB ID in ep.ids.tmdb is unique.
-                                        // Let's use that for enrichment to look up Season/Ep numbers.
-                                        val epTmdbId = ep.ids?.tmdb
-
-                                        if (epTmdbId != null) {
-                                            // We can't easily construct the standard "tmdb:SHOW:S:E" ID without S/E numbers.
-                                            // But wait! Trakt usually returns extended info if requested?
-                                            // For now, let's map it as best we can and let enrichment fix it.
-                                            MetaItem(
-                                                id = "trakt_ep:${show.ids.tmdb}:$epTmdbId", // Special marker
-                                                type = "episode",
-                                                name = "${show.title} - ${ep.number}",
-                                                description = "Paused at ${(item.progress ?: 0f).toInt()}%",
-                                                poster = null, background = null
-                                            )
-                                        } else {
-                                            null
-                                        }
-                                    } else null
-                                }
-                            }
-
-                            // 4. WATCHLISTS (Split)
-                            "trakt_watchlist_movies" -> {
-                                TraktClient.api.getWatchlist(bearer, clientId, type = "movies")
-                                    .mapNotNull { it.movie }
-                                    .map { MetaItem("tmdb:${it.ids.tmdb}", "movie", it.title, null, null, null) }
-                            }
-                            "trakt_watchlist_shows" -> {
-                                TraktClient.api.getWatchlist(bearer, clientId, type = "shows")
-                                    .mapNotNull { it.show }
-                                    .map { MetaItem("tmdb:${it.ids.tmdb}", "series", it.title, null, null, null) }
-                            }
-
-                            // 5. STANDARD LISTS
-                            "trakt_popular_movies" -> TraktClient.api.getPopularMovies(clientId).map { MetaItem("tmdb:${it.ids.tmdb}", "movie", it.title, null, null, null) }
-                            "trakt_popular_shows" -> TraktClient.api.getPopularShows(clientId).map { MetaItem("tmdb:${it.ids.tmdb}", "series", it.title, null, null, null) }
-                            "trakt_trending_movies" -> TraktClient.api.getTrendingMovies(clientId).mapNotNull { it.movie }.map { MetaItem("tmdb:${it.ids.tmdb}", "movie", it.title, null, null, null) }
-                            "trakt_trending_shows" -> TraktClient.api.getTrendingShows(clientId).mapNotNull { it.show }.map { MetaItem("tmdb:${it.ids.tmdb}", "series", it.title, null, null, null) }
-
-                            else -> emptyList()
-                        }
-
-                        // Enrich with TMDB Data (Posters, Episode IDs, Plots)
-                        val enriched = enrichWithTmdbMetadata(items, catalog.catalogId)
-                        _currentCatalogContent.postValue(enriched)
-
-                    } else {
-                        _error.postValue("Trakt not authenticated")
-                    }
-
-                } else if (catalog.catalogId in listOf("popular", "latest", "trending")) {
-                    // Standard TMDB Logic
-                    val pagesToLoad = listOf(1, 2, 3, 4, 5)
-                    val allItems = mutableListOf<MetaItem>()
-
-                    val deferredResults = pagesToLoad.map { page ->
-                        async {
-                            try {
-                                if (catalog.catalogType == "movie") {
-                                    when (catalog.catalogId) {
-                                        "popular" -> TMDBClient.api.getPopularMovies(apiKey, page = page)
-                                        "latest" -> TMDBClient.api.getLatestMovies(apiKey, page = page)
-                                        else -> TMDBClient.api.getTrendingMovies(apiKey, page = page)
-                                    }
-                                } else {
-                                    when (catalog.catalogId) {
-                                        "popular" -> TMDBClient.api.getPopularSeries(apiKey, page = page)
-                                        "latest" -> TMDBClient.api.getLatestSeries(apiKey, page = page)
-                                        else -> TMDBClient.api.getTrendingSeries(apiKey, page = page)
-                                    }
-                                }
-                            } catch (e: Exception) { null }
-                        }
-                    }
-                    val results = deferredResults.awaitAll()
-                    results.filterNotNull().forEach { response ->
-                        val fetchedItems = if (response is TMDBMovieListResponse) {
-                            response.results.map { it.toMetaItem() }
-                        } else if (response is TMDBSeriesListResponse) {
-                            response.results.map { it.toMetaItem() }
-                        } else { emptyList() }
-                        allItems.addAll(fetchedItems)
-                    }
-                    loadedContentCache.clear()
-                    loadedContentCache.addAll(allItems)
-                    _currentCatalogContent.postValue(loadedContentCache)
-
-                } else {
-                    // Local Logic (App Next Up, App Continue)
-                    val nonTMDBItems = when (catalog.catalogId) {
-                        "continue_movies" -> {
-                            val currentUserId = prefsManager.getCurrentUserId() ?: "default"
-                            catalogRepository.getContinueWatching(currentUserId, "movie").map { progress ->
-                                MetaItem(
-                                    id = progress.itemId,
-                                    type = progress.type,
-                                    name = progress.name ?: "Unknown",
-                                    poster = progress.poster,
-                                    background = progress.background,
-                                    description = null,
-                                    isWatched = progress.isWatched,
-                                    progress = progress.progress,
-                                    duration = progress.duration
-                                )
-                            }
-                        }
-                        "continue_episodes" -> {
-                            val currentUserId = prefsManager.getCurrentUserId() ?: "default"
-                            catalogRepository.getContinueWatching(currentUserId, "episode").map { progress ->
-                                MetaItem(
-                                    id = progress.itemId,
-                                    type = progress.type,
-                                    name = progress.name ?: "Unknown",
-                                    poster = progress.poster,
-                                    background = progress.background,
-                                    description = null,
-                                    isWatched = progress.isWatched,
-                                    progress = progress.progress,
-                                    duration = progress.duration
-                                )
-                            }
-                        }
-                        "next_up" -> generateNextUpList()
-                        else -> emptyList()
-                    }
-                    loadedContentCache.clear()
-                    loadedContentCache.addAll(nonTMDBItems)
-                    _currentCatalogContent.postValue(loadedContentCache)
-                }
-
-            } catch (e: Exception) {
-                _error.postValue("Failed to load content: ${e.message}")
-                loadedContentCache.clear()
-                _currentCatalogContent.postValue(emptyList())
-            } finally {
-                _isLoading.postValue(false)
-            }
-        }
-    }
-
-    private suspend fun enrichWithTmdbMetadata(items: List<MetaItem>, catalogId: String): List<MetaItem> {
-        return items.map { item ->
-            viewModelScope.async {
-                try {
-                    if (item.id.startsWith("trakt_ep:")) {
-                        // Handle Trakt Paused Episode with obscure ID
-                        val parts = item.id.split(":")
-                        val showTmdbId = parts[1].toIntOrNull()
-                        val epTmdbId = parts[2].toIntOrNull() // Not used for direct lookup yet, logic needs Show+Season+Ep
-
-                        if (showTmdbId != null && apiKey.isNotEmpty()) {
-                            // We need to find the Season/Episode numbers.
-                            // Since we don't have them from Trakt basic response, we might just fetch the SHOW info
-                            // and generic text. To do this perfectly requires querying TMDB for "Find by ID" or iterating seasons.
-
-                            // Simplified: Fetch Show details for poster
-                            val details = TMDBClient.api.getTVDetails(showTmdbId, apiKey)
-                            val poster = details.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" }
-                            val background = details.backdrop_path?.let { "https://image.tmdb.org/t/p/original$it" }
-
-                            // Construct a usable ID (defaults to S1E1 if unknown, or try to parse description?)
-                            // Ideally we'd fix the ID here.
-                            // New ID: "tmdb:SHOW_ID:1:1" (Fallback)
-                            val newId = "tmdb:$showTmdbId:1:1" // Placeholder if we can't resolve S/E
-
-                            item.copy(
-                                id = newId,
-                                poster = poster,
-                                background = background,
-                                name = "${details.name} - ${item.name}",
-                                description = "${item.description}\n\n(Resume info limited)"
-                            )
-                        } else item
-                    } else {
-                        // Standard Items
-                        val parts = item.id.removePrefix("tmdb:").split(":")
-                        val tmdbId = parts[0].toIntOrNull()
-
-                        if (tmdbId != null && apiKey.isNotEmpty()) {
-                            if (item.type == "movie") {
-                                val details = TMDBClient.api.getMovieDetails(tmdbId, apiKey)
-                                val poster = details.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" }
-                                val background = details.backdrop_path?.let { "https://image.tmdb.org/t/p/original$it" }
-                                item.copy(poster = poster, background = background, description = details.overview)
-                            } else {
-                                // Series or properly ID'd Episode
-                                val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)
-                                val poster = details.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" }
-                                val background = details.backdrop_path?.let { "https://image.tmdb.org/t/p/original$it" }
-                                item.copy(poster = poster, background = background, description = details.overview)
-                            }
-                        } else item
-                    }
-                } catch (e: Exception) { item }
-            }
-        }.awaitAll()
-    }
-
-    // === NEXT UP GENERATION (Corrected Logic) ===
-    private suspend fun generateNextUpList(): List<MetaItem> {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return emptyList()
-        val watchedEpisodes = catalogRepository.getNextUpCandidates(currentUserId)
-
-        val dateFormat = java.text.SimpleDateFormat("yyyy-MM-dd", java.util.Locale.getDefault())
-        val today = dateFormat.format(java.util.Date())
-
-        // Group by Series ID and find the LATEST watched episode
-        val latestEpisodesByShow = watchedEpisodes
-            .filter { it.parentId != null && it.season != null && it.episode != null }
-            .groupBy { it.parentId!! }
-            .mapValues { (_, episodes) ->
-                episodes.maxWithOrNull(compareBy<WatchProgress> { it.season!! }.thenBy { it.episode!! })
-            }
-
-        val nextUpItems = mutableListOf<MetaItem>()
-
-        for ((showId, latestEpisode) in latestEpisodesByShow) {
-            if (latestEpisode == null) continue
-
-            val tmdbId = showId.removePrefix("tmdb:").toIntOrNull() ?: continue
-            val currentSeason = latestEpisode.season!!
-            val currentEpisode = latestEpisode.episode!!
-
-            try {
-                val showDetails = TMDBClient.api.getTVDetails(tmdbId, apiKey)
-                var nextSeasonNum = currentSeason
-                var nextEpisodeNum = currentEpisode + 1
-                var potentialNextFound = false
-
-                val currentSeasonSpec = showDetails.seasons?.find { it.season_number == currentSeason }
-                if (currentSeasonSpec != null && currentEpisode < currentSeasonSpec.episode_count) {
-                    potentialNextFound = true
-                } else {
-                    val nextSeasonSpec = showDetails.seasons?.find { it.season_number == currentSeason + 1 }
-                    if (nextSeasonSpec != null && nextSeasonSpec.episode_count > 0) {
-                        nextSeasonNum = currentSeason + 1
-                        nextEpisodeNum = 1
-                        potentialNextFound = true
-                    }
-                }
-
-                if (potentialNextFound) {
-                    try {
-                        val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, nextSeasonNum, apiKey)
-                        val nextEpDetails = seasonDetails.episodes.find { it.episode_number == nextEpisodeNum }
-
-                        if (nextEpDetails != null) {
-                            // Check Air Date
-                            val isReleased = nextEpDetails.airDate == null || nextEpDetails.airDate <= today
-
-                            if (isReleased) {
-                                val nextEpisodeId = "$showId:$nextSeasonNum:$nextEpisodeNum"
-                                val nextEpisodeProgress = catalogRepository.getWatchProgress(currentUserId, nextEpisodeId)
-
-                                if (nextEpisodeProgress == null || !nextEpisodeProgress.isWatched) {
-                                    val poster = nextEpDetails.still_path?.let { "https://image.tmdb.org/t/p/w500$it" }
-                                        ?: showDetails.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" }
-
-                                    val background = nextEpDetails.still_path?.let { "https://image.tmdb.org/t/p/original$it" }
-                                        ?: showDetails.backdrop_path?.let { "https://image.tmdb.org/t/p/original$it" }
-
-                                    nextUpItems.add(
-                                        MetaItem(
-                                            id = nextEpisodeId,
-                                            type = "episode",
-                                            name = nextEpDetails.name,
-                                            poster = poster,
-                                            background = background,
-                                            description = nextEpDetails.overview ?: "Next episode"
-                                        )
-                                    )
-                                }
-                            }
-                        }
-                    } catch (e: Exception) { Log.e("NextUp", "Failed season details", e) }
-                }
-            } catch (e: Exception) { Log.e("NextUp", "Error processing next episode", e) }
-        }
-        return nextUpItems
-    }
-
-    // === TRAKT SYNC (Split Lists & History) ===
-
-    fun performTraktSync(syncHistory: Boolean, syncNextUp: Boolean, syncLists: Boolean, fetchMetadata: Boolean = true) {
-        if (!prefsManager.isTraktEnabled()) return
-
-        _traktSyncStatus.postValue(TraktSyncStatus.Syncing("Syncing..."))
-        viewModelScope.launch {
-            val userId = prefsManager.getCurrentUserId() ?: "default"
-            val token = prefsManager.getTraktAccessToken() ?: return@launch
-            val bearer = "Bearer $token"
-            val clientId = Secrets.TRAKT_CLIENT_ID
-            val tmdbMovieCache = mutableMapOf<Int, Pair<String?, String?>>()
-            val tmdbShowCache = mutableMapOf<Int, Pair<String?, String?>>()
-
-            try {
-                // 1. SYNC HISTORY (Movies & Shows)
-                if (syncHistory) {
-                    _traktSyncStatus.postValue(TraktSyncStatus.Syncing("Fetching watched history..."))
-
-                    // ... (Movies Sync Loop - Same as previous version) ...
-                    val watchedMovies = TraktClient.api.getWatchedMovies(bearer, clientId)
-                    watchedMovies.forEach { item ->
-                        item.movie?.ids?.tmdb?.let { tmdbId ->
-                            // Simplified: Just add empty/basic meta to Library if metadata fetch is off
-                            // If fetchMetadata is on, we'd do the heavy lifting here (omitted for brevity, using cache logic)
-                            val meta = MetaItem("tmdb:$tmdbId", "movie", item.movie.title, null, null, "Trakt Import")
-                            catalogRepository.addToLibrary(CollectedItem.fromMetaItem(userId, meta))
-                            // Save Progress
-                            catalogRepository.saveWatchProgress(WatchProgress(userId, meta.id, "movie", 0, 0, true, System.currentTimeMillis(), meta.name, null, null, null, null, null))
-                        }
-                    }
-
-                    // ... (Shows Sync Loop) ...
-                    val watchedShows = TraktClient.api.getWatchedShows(bearer, clientId)
-                    watchedShows.forEach { item ->
-                        item.show?.ids?.tmdb?.let { showTmdbId ->
-                            // Add Series to Library
-                            val seriesMeta = MetaItem("tmdb:$showTmdbId", "series", item.show.title, null, null, "Trakt Import")
-                            catalogRepository.addToLibrary(CollectedItem.fromMetaItem(userId, seriesMeta))
-
-                            // Add Episodes to Progress
-                            item.seasons?.forEach { season ->
-                                season.episodes.forEach { ep ->
-                                    val epId = "tmdb:$showTmdbId:${season.number}:${ep.number}"
-                                    catalogRepository.saveWatchProgress(
-                                        WatchProgress(userId, epId, "episode", 0, 0, true, System.currentTimeMillis(),
-                                            "${item.show.title} S${season.number}E${ep.number}", null, null, "tmdb:$showTmdbId", season.number, ep.number)
-                                    )
-                                }
-                            }
-                        }
-                    }
-                }
-
-                // 2. CREATE CATALOGS (Insert if missing)
-                if (syncNextUp) {
-                    val nextUp = UserCatalog(0, userId, "trakt_next_up", "series", "Next Up", null, 0, "series", "trakt", "trakt_official", true, true)
-                    if (!catalogRepository.isCatalogAdded(userId, "trakt_next_up", "series", "series")) {
-                        catalogRepository.insertCatalog(nextUp)
-                    }
-                }
-
-                if (syncLists) {
-                    val catalogs = listOf(
-                        UserCatalog(0, userId, "trakt_continue_movies", "movie", "Continue Watching", null, 0, "movies", "trakt", "trakt_official", true, true),
-                        UserCatalog(0, userId, "trakt_continue_shows", "series", "Continue Watching", null, 0, "series", "trakt", "trakt_official", true, true),
-                        UserCatalog(0, userId, "trakt_watchlist_movies", "movie", "Trakt Watchlist", null, 1, "movies", "trakt", "trakt_official", true, false),
-                        UserCatalog(0, userId, "trakt_watchlist_shows", "series", "Trakt Watchlist", null, 1, "series", "trakt", "trakt_official", true, false),
-                        UserCatalog(0, userId, "trakt_trending_movies", "movie", "Trakt Trending", null, 3, "movies", "trakt", "trakt_official", true, true),
-                        UserCatalog(0, userId, "trakt_trending_shows", "series", "Trakt Trending", null, 3, "series", "trakt", "trakt_official", true, true)
-                    )
-
-                    catalogs.forEach {
-                        if (!catalogRepository.isCatalogAdded(userId, it.catalogId, it.catalogType, it.pageType)) {
-                            catalogRepository.insertCatalog(it)
-                        }
-                    }
-                }
-
-                _traktSyncStatus.postValue(TraktSyncStatus.Success("Sync Complete"))
-
-            } catch (e: Exception) {
-                _traktSyncStatus.postValue(TraktSyncStatus.Error(e.message ?: "Error"))
-            } finally {
-                _isLoading.postValue(false)
-            }
-        }
-    }
-
-    private fun startPeriodicTraktSync() {
-        viewModelScope.launch {
-            while (prefsManager.isTraktEnabled()) {
-                delay(30 * 60 * 1000L) // Every 30 minutes
-                syncTraktLibrary()
-            }
-        }
-    }
-
-    // === WATCHED ACTION & REFRESH ===
-
-    fun markAsWatched(item: MetaItem, syncToTrakt: Boolean = true) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        val idStr = item.id.removePrefix("tmdb:")
-        val tmdbId = idStr.toIntOrNull()
-
-        viewModelScope.launch {
-            try {
-                // 1. Scrobble to Trakt
-                if (syncToTrakt && prefsManager.isTraktEnabled()) {
-                    val token = prefsManager.getTraktAccessToken()
-                    if (token != null) {
-                        val bearer = "Bearer $token"
-                        val body = if (item.type == "movie") {
-                            val id = item.id.removePrefix("tmdb:").toIntOrNull()
-                            if (id != null) TraktHistoryBody(movies = listOf(TraktMovie("", null, TraktIds(0, id, null, null)))) else null
-                        } else if (item.type == "episode") {
-                            // Parse "tmdb:SHOW:S:E"
-                            val parts = item.id.split(":")
-                            if (parts.size >= 4) {
-                                val s = parts[2].toIntOrNull()
-                                val e = parts[3].toIntOrNull()
-                                if (s != null && e != null) {
-                                    // Use episode numbers for history add
-                                    TraktHistoryBody(episodes = listOf(TraktEpisode(e, 1, null, null)))
-                                    // Note: Trakt strictly needs ID or Show+Season+Ep structure.
-                                    // A simple episode object might fail without context.
-                                    // Correct structure for adding episode to history using Show Context:
-                                    // We need the Show object wrapper.
-                                    // BUT simplified for this example.
-                                } else null
-                            } else null
-                        } else null
-
-                        if (body != null) {
-                            TraktClient.api.addToHistory(bearer, Secrets.TRAKT_CLIENT_ID, body)
-                        }
-                    }
-                }
-
-                // 2. Update Local DB
-                if (item.type == "series" && tmdbId != null && apiKey.isNotEmpty()) {
-                    // Mark whole series (fetch seasons -> mark all)
-                    val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)
-                    details.seasons?.forEach { season ->
-                        if (season.episode_count > 0) {
-                            val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, season.season_number, apiKey)
-                            seasonDetails.episodes.forEach { ep ->
-                                val epId = "tmdb:$tmdbId:${ep.season_number}:${ep.episode_number}"
-                                catalogRepository.saveWatchProgress(WatchProgress(currentUserId, epId, "episode", 0, 0, true, System.currentTimeMillis(), "${details.name} S${season.season_number}E${ep.episode_number}", null, null, "tmdb:$tmdbId", season.season_number, ep.episode_number))
-                            }
-                        }
-                    }
-                } else if (item.type == "episode") {
-                    // Mark single episode
-                    val parts = item.id.split(":")
-                    if (parts.size >= 4) {
-                        val parentId = "${parts[0]}:${parts[1]}"
-                        val s = parts[2].toIntOrNull()
-                        val e = parts[3].toIntOrNull()
-                        catalogRepository.saveWatchProgress(WatchProgress(currentUserId, item.id, "episode", 0, 0, true, System.currentTimeMillis(), item.name, item.poster, item.background, parentId, s, e))
-                    }
-                } else {
-                    // Movie
-                    catalogRepository.saveWatchProgress(WatchProgress(currentUserId, item.id, item.type, 0, 0, true, System.currentTimeMillis(), item.name, item.poster, item.background, null, null, null))
-                }
-
-                // 3. REFRESH UI IMMEDIATELY
-                // If we are viewing "Next Up", this refresh will trigger generateNextUpList again
-                // which now finds the NEW latest episode.
-                lastRequestedCatalog?.let {
-                    loadContentForCatalog(it, isInitialLoad = false)
-                }
-
-                _isItemWatched.postValue(true)
-                _actionResult.postValue(ActionResult.Success("Marked as watched"))
-
-            } catch (e: Exception) {
-                _actionResult.postValue(ActionResult.Error("Failed: ${e.message}"))
-            }
-        }
-    }
-
-    fun clearWatchedStatus(item: MetaItem, syncToTrakt: Boolean = true) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        val tmdbId = item.id.removePrefix("tmdb:").split(":")[0].toIntOrNull()
-
-        viewModelScope.launch {
-            try {
-                // Trakt Sync Removal
-                if (syncToTrakt && prefsManager.isTraktEnabled() && tmdbId != null) {
-                    val token = prefsManager.getTraktAccessToken()
-                    if (token != null) {
-                        val bearer = "Bearer $token"
-                        val body = if (item.type == "movie") {
-                            TraktHistoryBody(movies = listOf(TraktMovie("", null, TraktIds(0, tmdbId, null, null))))
-                        } else null // Episode removal complex without IDs
-
-                        if (body != null) TraktClient.api.removeFromHistory(bearer, Secrets.TRAKT_CLIENT_ID, body)
-                    }
-                }
-
-                // Local Update
-                catalogRepository.updateWatchedStatus(currentUserId, item.id, false)
-
-                // Refresh
-                lastRequestedCatalog?.let { loadContentForCatalog(it, isInitialLoad = false) }
-
-                _isItemWatched.postValue(false)
-                _actionResult.postValue(ActionResult.Success("Cleared watched status"))
-            } catch (e: Exception) {
-                _actionResult.postValue(ActionResult.Error("Failed: ${e.message}"))
-            }
-        }
-    }
-
-    // === STANDARD METHODS (Streams, Cast, Etc) ===
-    fun loadStreams(type: String, itemId: String) {
-        _isLoading.postValue(true)
-        viewModelScope.launch {
-            val allStreams = mutableListOf<Stream>()
-            val aioUsername = prefsManager.getAIOStreamsUsername()
-            val aioPassword = prefsManager.getAIOStreamsPassword()
-            val aioUrl = prefsManager.getAIOStreamsUrl() ?: "https://aiostreams.shiggsy.co.uk"
-
-            if (!aioUsername.isNullOrEmpty() && !aioPassword.isNullOrEmpty()) {
-                try {
-                    val aioApi = AIOStreamsClient.getApi(aioUrl, aioUsername, aioPassword)
-                    val aioResponse = aioApi.searchStreams(type, itemId)
-                    if (aioResponse.success && aioResponse.data != null) {
-                        allStreams.addAll(aioResponse.data.results)
-                    }
-                } catch (e: Exception) { Log.e("MainViewModel", "AIOStreams error", e) }
-            }
-            _streams.postValue(allStreams)
-            _isLoading.postValue(false)
-        }
-    }
-
-    fun loadEpisodeStreams(seriesId: String, season: Int, episode: Int) {
-        val episodeId = "$seriesId:$season:$episode"
-        loadStreams("series", episodeId)
-    }
-
-    fun loadSeriesMeta(itemId: String) {
-        if (apiKey.isEmpty()) return
-        viewModelScope.launch {
-            try {
-                val tmdbId = itemId.removePrefix("tmdb:").toIntOrNull() ?: return@launch
-                val details = TMDBClient.api.getTVDetails(tmdbId, apiKey)
-                val meta = Meta(
-                    id = itemId,
-                    type = "series",
-                    name = details.name,
-                    poster = details.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" },
-                    background = details.backdrop_path?.let { "https://image.tmdb.org/t/p/original$it" },
-                    description = details.overview,
-                    videos = details.seasons?.map { season ->
-                        Video(season.id.toString(), season.name, null, season.poster_path?.let { "https://image.tmdb.org/t/p/w500$it" }, null, season.season_number)
-                    }
-                )
-                _metaDetails.postValue(meta)
-            } catch (e: Exception) { _error.postValue("Failed to load series details: ${e.message}") }
-        }
-    }
-
-    fun loadSeasonEpisodes(seriesId: String, seasonNumber: Int) {
-        if (apiKey.isEmpty()) return
-        viewModelScope.launch {
-            try {
-                val tmdbId = seriesId.removePrefix("tmdb:").toIntOrNull() ?: return@launch
-                val seasonDetails = TMDBClient.api.getTVSeasonDetails(tmdbId, seasonNumber, apiKey)
-                val episodes = seasonDetails.episodes.map { episode ->
-                    MetaItem(
-                        id = "tmdb:$tmdbId:${episode.season_number}:${episode.episode_number}",
-                        type = "episode",
-                        name = episode.name,
-                        poster = episode.still_path?.let { "https://image.tmdb.org/t/p/w500$it" },
-                        background = null,
-                        description = episode.overview
-                    )
-                }
-                _seasonEpisodes.postValue(episodes)
-            } catch (e: Exception) { _error.postValue("Failed to load season episodes: ${e.message}") }
-        }
-    }
-
-    fun fetchCast(itemId: String, type: String) {
-        if (apiKey.isEmpty()) return
-        viewModelScope.launch {
-            try {
-                val tmdbId = itemId.removePrefix("tmdb:").toIntOrNull() ?: return@launch
-                val credits = if (type == "movie") TMDBClient.api.getMovieCredits(tmdbId, apiKey) else TMDBClient.api.getTVCredits(tmdbId, apiKey)
-                val cast = credits.cast.take(10).map { member ->
-                    MetaItem("tmdb:${member.id}", "person", member.name, member.profile_path?.let { "https://image.tmdb.org/t/p/w500$it" }, null, member.character)
-                }
-                val director = credits.crew.find { it.job == "Director" }?.let { member ->
-                    MetaItem("tmdb:${member.id}", "person", member.name, null, null, "Director")
-                }
-                _castList.postValue(cast)
-                _director.postValue(director)
-            } catch (e: Exception) { Log.e("MainViewModel", "Failed to fetch cast", e) }
-        }
-    }
-
-    fun checkWatchedStatus(itemId: String) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            val progress = catalogRepository.getWatchProgress(currentUserId, itemId)
-            _isItemWatched.postValue(progress?.isWatched ?: false)
-        }
-    }
-
-    fun saveWatchProgress(meta: MetaItem, currentPos: Long, duration: Long) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            val parts = meta.id.split(":")
-            val parentId = if (parts.size >= 3) "${parts[0]}:${parts[1]}" else null
-            val season = if (parts.size >= 3) parts[2].toIntOrNull() else null
-            val episode = if (parts.size >= 4) parts[3].toIntOrNull() else null
-
-            val progress = WatchProgress(
-                userId = currentUserId,
-                itemId = meta.id,
-                type = meta.type,
-                progress = currentPos,
-                duration = duration,
-                isWatched = currentPos >= duration * 0.9,
-                lastUpdated = System.currentTimeMillis(),
-                name = meta.name,
-                poster = meta.poster,
-                background = meta.background,
-                parentId = parentId,
-                season = season,
-                episode = episode
-            )
-            catalogRepository.saveWatchProgress(progress)
-        }
-    }
-
-    fun searchTMDB(query: String) {
-        if (apiKey.isEmpty() || query.isBlank()) return
-        _isSearching.postValue(true)
-        viewModelScope.launch {
-            try {
-                val response = TMDBClient.api.searchMulti(apiKey, query)
-                val results = response.results.filter { it.media_type == "movie" || it.media_type == "tv" }.map { it.toMetaItem() }
-                _searchResults.postValue(results)
-            } catch (e: Exception) {
-                _error.postValue("Search failed: ${e.message}")
-                _searchResults.postValue(emptyList())
-            } finally { _isSearching.postValue(false) }
-        }
-    }
-
-    fun searchMovies(query: String) {
-        if (apiKey.isEmpty() || query.isBlank()) return
-        _isSearching.postValue(true)
-        viewModelScope.launch {
-            try {
-                val response = TMDBClient.api.searchMovies(apiKey, query)
-                val results = response.results.map { it.toMetaItem() }
-                _searchResults.postValue(results)
-            } catch (e: Exception) {
-                _error.postValue("Movie search failed: ${e.message}")
-                _searchResults.postValue(emptyList())
-            } finally { _isSearching.postValue(false) }
-        }
-    }
-
-    fun searchSeries(query: String) {
-        if (apiKey.isEmpty() || query.isBlank()) return
-        _isSearching.postValue(true)
-        viewModelScope.launch {
-            try {
-                val response = TMDBClient.api.searchSeries(apiKey, query)
-                val results = response.results.map { it.toMetaItem() }
-                _searchResults.postValue(results)
-            } catch (e: Exception) {
-                _error.postValue("Series search failed: ${e.message}")
-                _searchResults.postValue(emptyList())
-            } finally { _isSearching.postValue(false) }
-        }
-    }
-
-    fun loadPersonCredits(personId: Int) {
-        if (apiKey.isEmpty()) return
-        _isSearching.postValue(true)
-        viewModelScope.launch {
-            try {
-                val response = TMDBClient.api.getPersonCombinedCredits(personId, apiKey)
-                val results = response.cast.map { it.toMetaItem() }
-                _searchResults.postValue(results)
-            } catch (e: Exception) {
-                _error.postValue("Person credits failed: ${e.message}")
-                _searchResults.postValue(emptyList())
-            } finally { _isSearching.postValue(false) }
-        }
-    }
-
-    fun clearSearchResults() { _searchResults.postValue(emptyList()) }
-
-    fun toggleWatchlist(meta: MetaItem, force: Boolean = false) {
-        if (apiKey.isEmpty()) return
-        val sessionId = prefsManager.getTMDBSessionId()
-        val accountId = prefsManager.getTMDBAccountId()
-        if (sessionId.isNullOrEmpty() || accountId == -1) return
-
-        viewModelScope.launch {
-            try {
-                val tmdbId = meta.id.removePrefix("tmdb:").toIntOrNull() ?: return@launch
-                val mediaType = if (meta.type == "series") "tv" else "movie"
-                val isCurrentlyInWatchlist = _isItemInWatchlist.value ?: false
-                val body = TMDBWatchlistBody(mediaType, tmdbId, if (force) true else !isCurrentlyInWatchlist)
-                TMDBClient.api.addToWatchlist(accountId, apiKey, sessionId, body)
-                _isItemInWatchlist.postValue(if (force) true else !isCurrentlyInWatchlist)
-                _actionResult.postValue(ActionResult.Success("Watchlist updated"))
-            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error("Watchlist operation failed: ${e.message}")) }
-        }
-    }
-
-    fun checkLibraryStatus(itemId: String) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            val isCollected = catalogRepository.isItemCollected(itemId, currentUserId)
-            _isItemInLibrary.postValue(isCollected)
-        }
-    }
-
-    fun checkWatchlistStatus(itemId: String, type: String) { _isItemInWatchlist.postValue(false) }
-
-    fun fetchRequestToken() {
-        if (apiKey.isEmpty()) return
-        viewModelScope.launch {
-            try {
-                val response = TMDBClient.api.createRequestToken(apiKey)
-                if (response.success) _requestToken.postValue(response.requestToken)
-                else _error.postValue("Failed to create TMDB request token")
-            } catch (e: Exception) { _error.postValue("TMDB Auth error: ${e.message}") }
-        }
-    }
-
-    fun createSession(requestToken: String) {
-        if (apiKey.isEmpty()) return
-        viewModelScope.launch {
-            try {
-                val body = mapOf("request_token" to requestToken)
-                val response = TMDBClient.api.createSession(apiKey, body)
-                if (response.success) {
-                    prefsManager.saveTMDBSessionId(response.sessionId)
-                    _sessionId.postValue(response.sessionId)
-                    val account = TMDBClient.api.getAccountDetails(apiKey, response.sessionId)
-                    prefsManager.saveTMDBAccountId(account.id)
-                    _actionResult.postValue(ActionResult.Success("TMDB connected successfully"))
-                } else { _error.postValue("Failed to create TMDB session") }
-            } catch (e: Exception) { _error.postValue("TMDB Session error: ${e.message}") }
-        }
-    }
-
-    fun checkTMDBAuthAndSync() {
-        val sessionId = prefsManager.getTMDBSessionId()
-        if (!sessionId.isNullOrEmpty() && apiKey.isNotEmpty()) _sessionId.postValue(sessionId)
-    }
-
-    fun initUserLists() {
-        viewModelScope.launch { catalogRepository.ensureUserListCatalogs(prefsManager.getCurrentUserId() ?: "default") }
-    }
-
-    fun initDefaultCatalogs() {
-        viewModelScope.launch { catalogRepository.initializeDefaultsIfNeeded() }
-    }
-
-    fun updateCatalogConfig(catalog: UserCatalog) {
-        viewModelScope.launch { catalogRepository.updateCatalog(catalog) }
-    }
-
-    fun swapCatalogOrder(catalog1: UserCatalog, catalog2: UserCatalog) {
-        viewModelScope.launch { catalogRepository.swapOrder(catalog1, catalog2) }
-    }
-
-    fun getDiscoverCatalogs(type: String): LiveData<List<UserCatalog>> {
-        return allCatalogConfigs.map { list ->
-            val traktEnabled = prefsManager.isTraktEnabled()
-            list.filter { cat ->
-                // HIDE local lists if Trakt is enabled to avoid duplicates/confusion
-                if (traktEnabled && (cat.catalogId == "continue_movies" || cat.catalogId == "continue_episodes" || cat.catalogId == "next_up")) {
-                    false
-                }
-                // HIDE Trakt lists if Trakt is disabled
-                else if (!traktEnabled && cat.catalogId.startsWith("trakt_")) {
-                    false
-                }
-                else {
-                    cat.catalogType == type && cat.showInDiscover
-                }
-            }.sortedBy { it.displayOrder }
-        }
-    }
-
-    fun filterAndSortLibrary(type: String, genre: String? = null, sortBy: String = "dateAdded", ascending: Boolean = false) {
-        viewModelScope.launch {
-            val rawItems = if (type == "movie") libraryMovies.value else librarySeries.value
-            if (rawItems == null) return@launch
-            val filtered = rawItems
-            val sorted = when (sortBy) {
-                "dateAdded" -> if (ascending) filtered else filtered.reversed()
-                "releaseDate" -> if (ascending) filtered.sortedBy { it.releaseDate ?: "" } else filtered.sortedByDescending { it.releaseDate ?: "" }
-                "title" -> if (ascending) filtered.sortedBy { it.name } else filtered.sortedByDescending { it.name }
-                else -> filtered
-            }
-            if (type == "movie") _filteredLibraryMovies.postValue(sorted) else _filteredLibrarySeries.postValue(sorted)
-        }
-    }
-
-    fun addToLibrary(meta: MetaItem, syncToTrakt: Boolean = true) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            try {
-                val item = CollectedItem.fromMetaItem(currentUserId, meta)
-                catalogRepository.addToLibrary(item)
-                _isItemInLibrary.postValue(true)
-                if (syncToTrakt && prefsManager.isTraktEnabled()) {
-                    // Sync logic omitted
-                }
-                _actionResult.postValue(ActionResult.Success("Added to library"))
-            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error("Failed to add to library: ${e.message}")) }
-        }
-    }
-
-    fun removeFromLibrary(itemId: String, syncToTrakt: Boolean = true) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            try {
-                catalogRepository.removeFromLibrary(itemId, currentUserId)
-                _isItemInLibrary.postValue(false)
-                _actionResult.postValue(ActionResult.Success("Removed from library"))
-            } catch (e: Exception) { _actionResult.postValue(ActionResult.Error("Failed to remove from library: ${e.message}")) }
-        }
-    }
-
-    fun toggleLibrary(meta: MetaItem) {
-        val currentUserId = prefsManager.getCurrentUserId() ?: return
-        viewModelScope.launch {
-            if (catalogRepository.isItemCollected(meta.id, currentUserId)) removeFromLibrary(meta.id) else addToLibrary(meta)
-        }
-    }
-
-    fun scrobble(action: String, meta: MetaItem, progress: Float) {
-        if (!prefsManager.isTraktEnabled()) return
-        val token = prefsManager.getTraktAccessToken() ?: return
-        val clientId = Secrets.TRAKT_CLIENT_ID
-        viewModelScope.launch {
-            try {
-                val idStr = meta.id.removePrefix("tmdb:")
-                val tmdbId = if (meta.type == "movie" || meta.type == "series") idStr.toIntOrNull() else 0
-                val body: TraktScrobbleBody? = if (meta.type == "movie" && tmdbId != null) {
-                    TraktScrobbleBody(progress, TraktMovie(meta.name, null, TraktIds(0, tmdbId, null, null)))
-                } else if (meta.type == "episode") {
-                    val parts = meta.id.split(":")
-                    if (parts.size >= 4) {
-                        val showId = parts[1].toIntOrNull()
-                        val s = parts[2].toIntOrNull()
-                        val e = parts[3].toIntOrNull()
-                        if (showId != null && s != null && e != null) {
-                            TraktScrobbleBody(progress, episode = TraktEpisode(s, e), show = TraktShow(meta.name, null, TraktIds(0, showId, null, null)))
-                        } else null
-                    } else null
-                } else null
-
-                if (body != null) {
-                    val bearer = "Bearer $token"
-                    when (action) {
-                        "start" -> TraktClient.api.startScrobble(bearer, clientId, body = body)
-                        "pause" -> TraktClient.api.pauseScrobble(bearer, clientId, body = body)
-                        "stop" -> TraktClient.api.stopScrobble(bearer, clientId, body = body)
-                    }
-                }
-            } catch (e: Exception) { Log.e("Trakt", "Scrobble failed", e) }
-        }
-    }
-
-    fun fetchItemLogo(meta: MetaItem) {
-        logoFetchJob?.cancel()
-        _currentLogo.value = ""
-        logoFetchJob = viewModelScope.launch {
-            try {
-                val idParts = meta.id.removePrefix("tmdb:").split(":")
-                val tmdbId = idParts[0].toIntOrNull()
-                if (tmdbId != null && apiKey.isNotEmpty()) {
-                    val images = if (meta.type == "movie") TMDBClient.api.getMovieImages(tmdbId, apiKey) else TMDBClient.api.getTVImages(tmdbId, apiKey)
-                    val logo = images.logos.firstOrNull()
-                    _currentLogo.postValue(logo?.let { "https://image.tmdb.org/t/p/w300${it.file_path}" })
-                } else { _currentLogo.postValue(null) }
-            } catch (e: Exception) { _currentLogo.postValue(null) }
-        }
-    }
-
-    sealed class TraktSyncStatus {
-        object Idle : TraktSyncStatus()
-        data class Syncing(val progress: String) : TraktSyncStatus()
-        data class Success(val message: String) : TraktSyncStatus()
-        data class Error(val message: String) : TraktSyncStatus()
-    }
-
-    sealed class ActionResult {
-        data class Success(val message: String) : ActionResult()
-        data class Error(val message: String) : ActionResult()
-    }
-}
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AndroidLayouts\">\n    <shared>\n      <config />\n    </shared>\n    <layouts>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/color/focus_indicator_selector.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/avatar_background.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/background_content_box.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/badge_background.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/button_background.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/default_background.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/gradient_overlay.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/gradient_overlay_modern.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_arrow_back_white_24dp.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_arrow_drop_down.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_arrow_up.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_check_circle.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_discover.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_exit_to_app.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_person.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_search_off.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_star.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/ic_tv.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/modern_button_background.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/modern_focus_selector.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/modern_gradient_overlay.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/modern_rating_badge.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/poster_gradient_overlay.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/drawable/selector_focus_border.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/activity_details2.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml\">\n        <config>\n          <state>Portrait</state>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/activity_player.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/activity_settings.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/activity_user_selection.xml\">\n        <config>\n          <state>Portrait</state>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/dialog_tmdb_auth.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_discover.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_library.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_library_new.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_movies.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_search.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_search_new.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/fragment_series.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_catalog_config.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_catalog_config_settings.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_discover_catalog.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_discover_sidebar.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_home_section.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_poster.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_stream.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_user_list.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/layout/item_user_profile.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer</theme>\n        </config>\n      </layout>\n      <layout url=\"file://$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml\">\n        <config>\n          <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>\n        </config>\n      </layout>\n    </layouts>\n  </component>\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"NONE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"2c02766e-19a3-4317-ae82-959ae60a24cb\" name=\"Changes\" comment=\"Update visual assets\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/app/build/outputs/logs/manifest-merger-debug-report.txt\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/TMDBModels.kt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/TMDBModels.kt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"device_and_snapshot_combo_box_target[]\" />\n  <component name=\"ExternalProjectsData\">\n    <projectState path=\"$PROJECT_DIR$\">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name=\"ExternalProjectsManager\">\n    <system id=\"GRADLE\">\n      <state>\n        <projects_view>\n          <tree_state>\n            <expand>\n              <path>\n                <item name=\"\" type=\"6a2764b6:ExternalProjectsStructure$RootNode\" />\n                <item name=\"StremioMPVPlayer\" type=\"f1a62948:ProjectNode\" />\n              </path>\n            </expand>\n            <select />\n          </tree_state>\n        </projects_view>\n      </state>\n    </system>\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Kotlin Data Class\" />\n        <option value=\"Class\" />\n        <option value=\"Kotlin File\" />\n        <option value=\"resourceFile\" />\n        <option value=\"valueResourceFile\" />\n        <option value=\"Kotlin Class\" />\n        <option value=\"layoutResourceFile\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"GenerateSignedApkSettings\">\n    <option name=\"BUILD_TARGET_KEY\" value=\"apk\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;shiggsy365-maker&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/shiggsy365/Strub.git&quot;,\n    &quot;accountId&quot;: &quot;4bb637b3-d6d5-4661-b5ed-e0473b167b56&quot;\n  }\n}</component>\n  <component name=\"ProblemsViewState\">\n    <option name=\"selectedTabId\" value=\"CurrentFile\" />\n    <option name=\"showPreview\" value=\"true\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 0\n}</component>\n  <component name=\"ProjectId\" id=\"35bEU0DGeQmI8RsswKzeu8HRMFt\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"1\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Android App.app.executor&quot;: &quot;Run&quot;,\n    &quot;ApkExportedModule&quot;: &quot;StremioMPVPlayer.app&quot;,\n    &quot;ModuleVcsDetector.initialDetectionPerformed&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.readMode.enableVisualFormatting&quot;: &quot;true&quot;,\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,\n    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;com.google.services.firebase.aqiPopupShown&quot;: &quot;true&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/home/jon/AndroidStudioProjects/Slingshot/app/src/main/res/values&quot;,\n    &quot;project.structure.last.edited&quot;: &quot;Variables&quot;,\n    &quot;project.structure.proportion&quot;: &quot;0.17&quot;,\n    &quot;project.structure.side.proportion&quot;: &quot;0.0&quot;,\n    &quot;recommended.upgrade.last.time.stamp&quot;: &quot;1763425586759&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;memory.settings&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"android.template.326038633\">\n      <recent name=\"com.example.stremiompvplayer\" />\n    </key>\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/values\" />\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/drawable\" />\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/layout\" />\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/animator\" />\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/color\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/drawable\" />\n      <recent name=\"$PROJECT_DIR$/app/src/main/res/color\" />\n    </key>\n    <key name=\"K2MoveDeclarationsDialog.RECENT_PACKAGE_KEY\">\n      <recent name=\"xyz.mpv.is.xyz.mpv\" />\n      <recent name=\"com.example.stremiompvplayer.network\" />\n      <recent name=\"com.example.stremiompvplayer.models\" />\n      <recent name=\"com.example.stremiompvplayer.data\" />\n      <recent name=\"com.example.stremiompvplayer.viewmodels\" />\n    </key>\n  </component>\n  <component name=\"RunManager\">\n    <configuration name=\"app\" type=\"AndroidRunConfigurationType\" factoryName=\"Android App\" activateToolWindowBeforeRun=\"false\">\n      <module name=\"Slingshot.app\" />\n      <option name=\"ANDROID_RUN_CONFIGURATION_SCHEMA_VERSION\" value=\"1\" />\n      <option name=\"DEPLOY\" value=\"true\" />\n      <option name=\"DEPLOY_APK_FROM_BUNDLE\" value=\"false\" />\n      <option name=\"DEPLOY_AS_INSTANT\" value=\"false\" />\n      <option name=\"ARTIFACT_NAME\" value=\"\" />\n      <option name=\"PM_INSTALL_OPTIONS\" value=\"\" />\n      <option name=\"ALL_USERS\" value=\"false\" />\n      <option name=\"ALWAYS_INSTALL_WITH_PM\" value=\"false\" />\n      <option name=\"ALLOW_ASSUME_VERIFIED\" value=\"false\" />\n      <option name=\"CLEAR_APP_STORAGE\" value=\"false\" />\n      <option name=\"DYNAMIC_FEATURES_DISABLED_LIST\" value=\"\" />\n      <option name=\"ACTIVITY_EXTRA_FLAGS\" value=\"\" />\n      <option name=\"MODE\" value=\"default_activity\" />\n      <option name=\"RESTORE_ENABLED\" value=\"false\" />\n      <option name=\"RESTORE_FILE\" value=\"\" />\n      <option name=\"RESTORE_FRESH_INSTALL_ONLY\" value=\"false\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"DEVICE_AND_SNAPSHOT_COMBO_BOX\" />\n      <option name=\"SELECTED_CLOUD_MATRIX_CONFIGURATION_ID\" value=\"-1\" />\n      <option name=\"SELECTED_CLOUD_MATRIX_PROJECT_ID\" value=\"\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Auto\" />\n      <Auto>\n        <option name=\"USE_JAVA_AWARE_DEBUGGER\" value=\"false\" />\n        <option name=\"SHOW_STATIC_VARS\" value=\"true\" />\n        <option name=\"WORKING_DIR\" value=\"\" />\n        <option name=\"TARGET_LOGGING_CHANNELS\" value=\"lldb process:gdb-remote packets\" />\n        <option name=\"SHOW_OPTIMIZED_WARNING\" value=\"true\" />\n        <option name=\"ATTACH_ON_WAIT_FOR_DEBUGGER\" value=\"false\" />\n        <option name=\"DEBUG_SANDBOX_SDK\" value=\"false\" />\n      </Auto>\n      <Hybrid>\n        <option name=\"USE_JAVA_AWARE_DEBUGGER\" value=\"false\" />\n        <option name=\"SHOW_STATIC_VARS\" value=\"true\" />\n        <option name=\"WORKING_DIR\" value=\"\" />\n        <option name=\"TARGET_LOGGING_CHANNELS\" value=\"lldb process:gdb-remote packets\" />\n        <option name=\"SHOW_OPTIMIZED_WARNING\" value=\"true\" />\n        <option name=\"ATTACH_ON_WAIT_FOR_DEBUGGER\" value=\"false\" />\n        <option name=\"DEBUG_SANDBOX_SDK\" value=\"false\" />\n      </Hybrid>\n      <Java>\n        <option name=\"ATTACH_ON_WAIT_FOR_DEBUGGER\" value=\"false\" />\n        <option name=\"DEBUG_SANDBOX_SDK\" value=\"false\" />\n      </Java>\n      <Native>\n        <option name=\"USE_JAVA_AWARE_DEBUGGER\" value=\"false\" />\n        <option name=\"SHOW_STATIC_VARS\" value=\"true\" />\n        <option name=\"WORKING_DIR\" value=\"\" />\n        <option name=\"TARGET_LOGGING_CHANNELS\" value=\"lldb process:gdb-remote packets\" />\n        <option name=\"SHOW_OPTIMIZED_WARNING\" value=\"true\" />\n        <option name=\"ATTACH_ON_WAIT_FOR_DEBUGGER\" value=\"false\" />\n        <option name=\"DEBUG_SANDBOX_SDK\" value=\"false\" />\n      </Native>\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Java/Kotlin Method Sample (legacy)\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <option name=\"DEEP_LINK\" value=\"\" />\n      <option name=\"ACTIVITY\" value=\"\" />\n      <option name=\"ACTIVITY_CLASS\" value=\"\" />\n      <option name=\"SEARCH_ACTIVITY_IN_GLOBAL_SCOPE\" value=\"false\" />\n      <option name=\"SKIP_ACTIVITY_VALIDATION\" value=\"false\" />\n      <method v=\"2\">\n        <option name=\"Android.Gradle.BeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"2c02766e-19a3-4317-ae82-959ae60a24cb\" name=\"Changes\" comment=\"\" />\n      <created>1763370382391</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1763370382391</updated>\n    </task>\n    <task id=\"LOCAL-00032\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763487469223</created>\n      <option name=\"number\" value=\"00032\" />\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763487469223</updated>\n    </task>\n    <task id=\"LOCAL-00033\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763487473669</created>\n      <option name=\"number\" value=\"00033\" />\n      <option name=\"presentableId\" value=\"LOCAL-00033\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763487473669</updated>\n    </task>\n    <task id=\"LOCAL-00034\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763487477697</created>\n      <option name=\"number\" value=\"00034\" />\n      <option name=\"presentableId\" value=\"LOCAL-00034\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763487477697</updated>\n    </task>\n    <task id=\"LOCAL-00035\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763505575487</created>\n      <option name=\"number\" value=\"00035\" />\n      <option name=\"presentableId\" value=\"LOCAL-00035\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763505575487</updated>\n    </task>\n    <task id=\"LOCAL-00036\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763505580271</created>\n      <option name=\"number\" value=\"00036\" />\n      <option name=\"presentableId\" value=\"LOCAL-00036\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763505580271</updated>\n    </task>\n    <task id=\"LOCAL-00037\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763509962730</created>\n      <option name=\"number\" value=\"00037\" />\n      <option name=\"presentableId\" value=\"LOCAL-00037\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763509962730</updated>\n    </task>\n    <task id=\"LOCAL-00038\" summary=\"stremio addon implementation\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763509967987</created>\n      <option name=\"number\" value=\"00038\" />\n      <option name=\"presentableId\" value=\"LOCAL-00038\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763509967987</updated>\n    </task>\n    <task id=\"LOCAL-00039\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763516519379</created>\n      <option name=\"number\" value=\"00039\" />\n      <option name=\"presentableId\" value=\"LOCAL-00039\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763516519379</updated>\n    </task>\n    <task id=\"LOCAL-00040\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763516529233</created>\n      <option name=\"number\" value=\"00040\" />\n      <option name=\"presentableId\" value=\"LOCAL-00040\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763516529233</updated>\n    </task>\n    <task id=\"LOCAL-00041\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763579382410</created>\n      <option name=\"number\" value=\"00041\" />\n      <option name=\"presentableId\" value=\"LOCAL-00041\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763579382410</updated>\n    </task>\n    <task id=\"LOCAL-00042\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763582771262</created>\n      <option name=\"number\" value=\"00042\" />\n      <option name=\"presentableId\" value=\"LOCAL-00042\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763582771262</updated>\n    </task>\n    <task id=\"LOCAL-00043\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763590590176</created>\n      <option name=\"number\" value=\"00043\" />\n      <option name=\"presentableId\" value=\"LOCAL-00043\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763590590176</updated>\n    </task>\n    <task id=\"LOCAL-00044\" summary=\"Visual layout for movies page\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763590604434</created>\n      <option name=\"number\" value=\"00044\" />\n      <option name=\"presentableId\" value=\"LOCAL-00044\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763590604434</updated>\n    </task>\n    <task id=\"LOCAL-00045\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763595922620</created>\n      <option name=\"number\" value=\"00045\" />\n      <option name=\"presentableId\" value=\"LOCAL-00045\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763595922620</updated>\n    </task>\n    <task id=\"LOCAL-00046\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763595971951</created>\n      <option name=\"number\" value=\"00046\" />\n      <option name=\"presentableId\" value=\"LOCAL-00046\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763595971951</updated>\n    </task>\n    <task id=\"LOCAL-00047\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763598212987</created>\n      <option name=\"number\" value=\"00047\" />\n      <option name=\"presentableId\" value=\"LOCAL-00047\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763598212987</updated>\n    </task>\n    <task id=\"LOCAL-00048\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763598221577</created>\n      <option name=\"number\" value=\"00048\" />\n      <option name=\"presentableId\" value=\"LOCAL-00048\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763598221577</updated>\n    </task>\n    <task id=\"LOCAL-00049\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763605788880</created>\n      <option name=\"number\" value=\"00049\" />\n      <option name=\"presentableId\" value=\"LOCAL-00049\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763605788880</updated>\n    </task>\n    <task id=\"LOCAL-00050\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763643379483</created>\n      <option name=\"number\" value=\"00050\" />\n      <option name=\"presentableId\" value=\"LOCAL-00050\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763643379483</updated>\n    </task>\n    <task id=\"LOCAL-00051\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763643383811</created>\n      <option name=\"number\" value=\"00051\" />\n      <option name=\"presentableId\" value=\"LOCAL-00051\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763643383811</updated>\n    </task>\n    <task id=\"LOCAL-00052\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763655904325</created>\n      <option name=\"number\" value=\"00052\" />\n      <option name=\"presentableId\" value=\"LOCAL-00052\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763655904325</updated>\n    </task>\n    <task id=\"LOCAL-00053\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763655908225</created>\n      <option name=\"number\" value=\"00053\" />\n      <option name=\"presentableId\" value=\"LOCAL-00053\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763655908225</updated>\n    </task>\n    <task id=\"LOCAL-00054\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763669116147</created>\n      <option name=\"number\" value=\"00054\" />\n      <option name=\"presentableId\" value=\"LOCAL-00054\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763669116148</updated>\n    </task>\n    <task id=\"LOCAL-00055\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763679361942</created>\n      <option name=\"number\" value=\"00055\" />\n      <option name=\"presentableId\" value=\"LOCAL-00055\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763679361942</updated>\n    </task>\n    <task id=\"LOCAL-00056\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763679373264</created>\n      <option name=\"number\" value=\"00056\" />\n      <option name=\"presentableId\" value=\"LOCAL-00056\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763679373264</updated>\n    </task>\n    <task id=\"LOCAL-00057\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763679827037</created>\n      <option name=\"number\" value=\"00057\" />\n      <option name=\"presentableId\" value=\"LOCAL-00057\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763679827037</updated>\n    </task>\n    <task id=\"LOCAL-00058\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763682505573</created>\n      <option name=\"number\" value=\"00058\" />\n      <option name=\"presentableId\" value=\"LOCAL-00058\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763682505573</updated>\n    </task>\n    <task id=\"LOCAL-00059\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763686235292</created>\n      <option name=\"number\" value=\"00059\" />\n      <option name=\"presentableId\" value=\"LOCAL-00059\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763686235292</updated>\n    </task>\n    <task id=\"LOCAL-00060\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763686243806</created>\n      <option name=\"number\" value=\"00060\" />\n      <option name=\"presentableId\" value=\"LOCAL-00060\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763686243806</updated>\n    </task>\n    <task id=\"LOCAL-00061\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763691342932</created>\n      <option name=\"number\" value=\"00061\" />\n      <option name=\"presentableId\" value=\"LOCAL-00061\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763691342933</updated>\n    </task>\n    <task id=\"LOCAL-00062\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763758475334</created>\n      <option name=\"number\" value=\"00062\" />\n      <option name=\"presentableId\" value=\"LOCAL-00062\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763758475334</updated>\n    </task>\n    <task id=\"LOCAL-00063\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763758496450</created>\n      <option name=\"number\" value=\"00063\" />\n      <option name=\"presentableId\" value=\"LOCAL-00063\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763758496450</updated>\n    </task>\n    <task id=\"LOCAL-00064\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763772979008</created>\n      <option name=\"number\" value=\"00064\" />\n      <option name=\"presentableId\" value=\"LOCAL-00064\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763772979008</updated>\n    </task>\n    <task id=\"LOCAL-00065\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763780792504</created>\n      <option name=\"number\" value=\"00065\" />\n      <option name=\"presentableId\" value=\"LOCAL-00065\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763780792504</updated>\n    </task>\n    <task id=\"LOCAL-00066\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763781680385</created>\n      <option name=\"number\" value=\"00066\" />\n      <option name=\"presentableId\" value=\"LOCAL-00066\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763781680385</updated>\n    </task>\n    <task id=\"LOCAL-00067\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763781687735</created>\n      <option name=\"number\" value=\"00067\" />\n      <option name=\"presentableId\" value=\"LOCAL-00067\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763781687735</updated>\n    </task>\n    <task id=\"LOCAL-00068\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763841397996</created>\n      <option name=\"number\" value=\"00068\" />\n      <option name=\"presentableId\" value=\"LOCAL-00068\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763841397997</updated>\n    </task>\n    <task id=\"LOCAL-00069\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763841402897</created>\n      <option name=\"number\" value=\"00069\" />\n      <option name=\"presentableId\" value=\"LOCAL-00069\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763841402897</updated>\n    </task>\n    <task id=\"LOCAL-00070\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763843391998</created>\n      <option name=\"number\" value=\"00070\" />\n      <option name=\"presentableId\" value=\"LOCAL-00070\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763843391998</updated>\n    </task>\n    <task id=\"LOCAL-00071\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763843395344</created>\n      <option name=\"number\" value=\"00071\" />\n      <option name=\"presentableId\" value=\"LOCAL-00071\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763843395344</updated>\n    </task>\n    <task id=\"LOCAL-00072\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763855755799</created>\n      <option name=\"number\" value=\"00072\" />\n      <option name=\"presentableId\" value=\"LOCAL-00072\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763855755799</updated>\n    </task>\n    <task id=\"LOCAL-00073\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763855759947</created>\n      <option name=\"number\" value=\"00073\" />\n      <option name=\"presentableId\" value=\"LOCAL-00073\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763855759947</updated>\n    </task>\n    <task id=\"LOCAL-00074\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763858879211</created>\n      <option name=\"number\" value=\"00074\" />\n      <option name=\"presentableId\" value=\"LOCAL-00074\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763858879211</updated>\n    </task>\n    <task id=\"LOCAL-00075\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763858883537</created>\n      <option name=\"number\" value=\"00075\" />\n      <option name=\"presentableId\" value=\"LOCAL-00075\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763858883537</updated>\n    </task>\n    <task id=\"LOCAL-00076\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763860063035</created>\n      <option name=\"number\" value=\"00076\" />\n      <option name=\"presentableId\" value=\"LOCAL-00076\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763860063036</updated>\n    </task>\n    <task id=\"LOCAL-00077\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763861917655</created>\n      <option name=\"number\" value=\"00077\" />\n      <option name=\"presentableId\" value=\"LOCAL-00077\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763861917655</updated>\n    </task>\n    <task id=\"LOCAL-00078\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763914215899</created>\n      <option name=\"number\" value=\"00078\" />\n      <option name=\"presentableId\" value=\"LOCAL-00078\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763914215899</updated>\n    </task>\n    <task id=\"LOCAL-00079\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763914363460</created>\n      <option name=\"number\" value=\"00079\" />\n      <option name=\"presentableId\" value=\"LOCAL-00079\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763914363460</updated>\n    </task>\n    <task id=\"LOCAL-00080\" summary=\"Update visual assets\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1763917831928</created>\n      <option name=\"number\" value=\"00080\" />\n      <option name=\"presentableId\" value=\"LOCAL-00080\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1763917831928</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"81\" />\n    <servers />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <ignored-roots>\n      <path value=\"$PROJECT_DIR$/mpv-android\" />\n    </ignored-roots>\n    <MESSAGE value=\"error fixes\" />\n    <MESSAGE value=\"stremio addon implementation\" />\n    <MESSAGE value=\"Visual layout for movies page\" />\n    <MESSAGE value=\"Update visual assets\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Update visual assets\" />\n    <option name=\"GROUP_MULTIFILE_MERGE_BY_DIRECTORY\" value=\"true\" />\n  </component>\n  <component name=\"play_dynamic_filters_status\">\n    <option name=\"appIdToCheckInfo\">\n      <map>\n        <entry key=\"com.example.stremiompvplayer\">\n          <value>\n            <CheckInfo lastCheckTimestamp=\"1763841400053\" />\n          </value>\n        </entry>\n        <entry key=\"com.example.stremiompvplayer.test\">\n          <value>\n            <CheckInfo lastCheckTimestamp=\"1763841400056\" />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision ef9ce7c7ce0a9d5af84568b8300fe6c75b7af4c8)
+++ b/.idea/workspace.xml	(date 1763935969239)
@@ -132,7 +132,6 @@
       </layout>
       <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
         <config>
-          <state>Portrait</state>
           <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>
         </config>
       </layout>
@@ -148,7 +147,6 @@
       </layout>
       <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/activity_user_selection.xml">
         <config>
-          <state>Portrait</state>
           <theme>@style/Theme.StremioMPVPlayer</theme>
         </config>
       </layout>
@@ -162,11 +160,6 @@
           <theme>@style/Theme.StremioMPVPlayer</theme>
         </config>
       </layout>
-      <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml">
-        <config>
-          <theme>@style/Theme.StremioMPVPlayer</theme>
-        </config>
-      </layout>
       <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/fragment_library.xml">
         <config>
           <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>
@@ -215,11 +208,6 @@
       <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/item_discover_sidebar.xml">
         <config>
           <theme>@style/Theme.StremioMPVPlayer.Leanback</theme>
-        </config>
-      </layout>
-      <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/item_home_section.xml">
-        <config>
-          <theme>@style/Theme.StremioMPVPlayer</theme>
         </config>
       </layout>
       <layout url="file://$PROJECT_DIR$/app/src/main/res/layout/item_poster.xml">
@@ -265,10 +253,10 @@
   <component name="ChangeListManager">
     <list default="true" id="2c02766e-19a3-4317-ae82-959ae60a24cb" name="Changes" comment="Update visual assets">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/app/build/outputs/logs/manifest-merger-debug-report.txt" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/TMDBModels.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/TMDBModels.kt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/models/UserCatalogDao.kt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TMDBApiService.kt" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/network/TraktClient.kt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/ui/discover/DiscoverFragment.kt" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt" beforeDir="false" afterPath="$PROJECT_DIR$/app/src/main/java/com/example/stremiompvplayer/viewmodels/MainViewModel.kt" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -279,7 +267,7 @@
   <component name="ClangdSettings">
     <option name="formatViaClangd" value="false" />
   </component>
-  <component name="ExecutionTargetManager" SELECTED_TARGET="device_and_snapshot_combo_box_target[]" />
+  <component name="ExecutionTargetManager" SELECTED_TARGET="device_and_snapshot_combo_box_target[DeviceId(pluginId=Default, isTemplate=false, identifier=serial=192.168.1.247:5555;connection=6fc0cebc)]" />
   <component name="ExternalProjectsData">
     <projectState path="$PROJECT_DIR$">
       <ProjectState />
@@ -310,8 +298,8 @@
         <option value="Kotlin File" />
         <option value="resourceFile" />
         <option value="valueResourceFile" />
-        <option value="Kotlin Class" />
         <option value="layoutResourceFile" />
+        <option value="Kotlin Class" />
       </list>
     </option>
   </component>
@@ -396,7 +384,7 @@
   </component>
   <component name="RunManager">
     <configuration name="app" type="AndroidRunConfigurationType" factoryName="Android App" activateToolWindowBeforeRun="false">
-      <module name="Slingshot.app" />
+      <module name="BINGE.app" />
       <option name="ANDROID_RUN_CONFIGURATION_SCHEMA_VERSION" value="1" />
       <option name="DEPLOY" value="true" />
       <option name="DEPLOY_APK_FROM_BUNDLE" value="false" />
